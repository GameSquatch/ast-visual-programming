'use strict';

var svelte$1 = require('@testing-library/svelte');
var internal = require('svelte/internal');
var transition = require('svelte/transition');
var easing = require('svelte/easing');
var uuid = require('uuid');
var store = require('svelte/store');
var svelte = require('svelte');
var animate = require('svelte/animate');
var chai = require('chai');

/** @type {DragStartDataCreator} */

/** @type {MoveExpressionDragStartDataCreator} */
const moveExpressionDrag = (expressionNode, currentIndex) => ({ dragType: "moveExpression", node: expressionNode, currentIndex });

/** @type {VariableDragStartDataCreator} */
const variableDrag = (variableData) => ({ dragType: "variable", data: variableData });

/* src/components/FunctionInfoTab.svelte generated by Svelte v3.46.4 */

const { Object: Object_1$3 } = internal.globals;
const file$d = "src/components/FunctionInfoTab.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i];
	child_ctx[15] = i;
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	const constants_0 = /*info*/ child_ctx[0].variables[/*varId*/ child_ctx[16]];
	child_ctx[17] = constants_0;
	return child_ctx;
}

// (78:4) {#if isDisplaying}
function create_if_block$5(ctx) {
	let div8;
	let div5;
	let h40;
	let t1;
	let div3;
	let div0;
	let t3;
	let div1;
	let t5;
	let div2;
	let t7;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let t8;
	let div4;
	let button0;
	let t10;
	let div7;
	let h41;
	let t12;
	let t13;
	let div6;
	let button1;
	let div8_transition;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = Object.keys(/*info*/ ctx[0].variables);
	internal.validate_each_argument(each_value_1);
	const get_key = ctx => /*varId*/ ctx[16];
	internal.validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$2(key, child_ctx));
	}

	let each_value = /*info*/ ctx[0].parameters;
	internal.validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div8 = internal.element("div");
			div5 = internal.element("div");
			h40 = internal.element("h4");
			h40.textContent = "Variables";
			t1 = internal.space();
			div3 = internal.element("div");
			div0 = internal.element("div");
			div0.textContent = "Name";
			t3 = internal.space();
			div1 = internal.element("div");
			div1.textContent = "Type";
			t5 = internal.space();
			div2 = internal.element("div");
			div2.textContent = "Default Value";
			t7 = internal.space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t8 = internal.space();
			div4 = internal.element("div");
			button0 = internal.element("button");
			button0.textContent = "Add Variable";
			t10 = internal.space();
			div7 = internal.element("div");
			h41 = internal.element("h4");
			h41.textContent = "Parameters";
			t12 = internal.space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t13 = internal.space();
			div6 = internal.element("div");
			button1 = internal.element("button");
			button1.textContent = "Add Variable";
			internal.add_location(h40, file$d, 80, 12, 2152);
			internal.attr_dev(div0, "class", "flex-1");
			internal.add_location(div0, file$d, 82, 16, 2251);
			internal.attr_dev(div1, "class", "flex-1");
			internal.add_location(div1, file$d, 83, 16, 2298);
			internal.attr_dev(div2, "class", "flex-1");
			internal.add_location(div2, file$d, 84, 16, 2345);
			internal.attr_dev(div3, "class", "flex w100 space-between var-container");
			internal.add_location(div3, file$d, 81, 12, 2183);
			internal.add_location(button0, file$d, 99, 16, 3325);
			internal.attr_dev(div4, "class", "add-var-btn");
			internal.add_location(div4, file$d, 98, 12, 3283);
			internal.attr_dev(div5, "class", "flex-1 var-section svelte-d9q3dk");
			internal.add_location(div5, file$d, 79, 8, 2107);
			internal.add_location(h41, file$d, 103, 12, 3467);
			internal.add_location(button1, file$d, 111, 16, 3926);
			internal.attr_dev(div6, "class", "add-var-btn");
			internal.add_location(div6, file$d, 110, 12, 3884);
			internal.attr_dev(div7, "class", "flex-1 param-section svelte-d9q3dk");
			internal.add_location(div7, file$d, 102, 8, 3420);
			internal.attr_dev(div8, "class", "flex tab-content svelte-d9q3dk");
			internal.add_location(div8, file$d, 78, 4, 2011);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div8, anchor);
			internal.append_dev(div8, div5);
			internal.append_dev(div5, h40);
			internal.append_dev(div5, t1);
			internal.append_dev(div5, div3);
			internal.append_dev(div3, div0);
			internal.append_dev(div3, t3);
			internal.append_dev(div3, div1);
			internal.append_dev(div3, t5);
			internal.append_dev(div3, div2);
			internal.append_dev(div5, t7);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div5, null);
			}

			internal.append_dev(div5, t8);
			internal.append_dev(div5, div4);
			internal.append_dev(div4, button0);
			internal.append_dev(div8, t10);
			internal.append_dev(div8, div7);
			internal.append_dev(div7, h41);
			internal.append_dev(div7, t12);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div7, null);
			}

			internal.append_dev(div7, t13);
			internal.append_dev(div7, div6);
			internal.append_dev(div6, button1);
			current = true;

			if (!mounted) {
				dispose = [
					internal.listen_dev(button0, "click", /*addVariable*/ ctx[4], false, false, false),
					internal.listen_dev(button1, "click", /*addParameter*/ ctx[5], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*dragStart, info, Object, varTypeChange, changeVarName*/ 393) {
				each_value_1 = Object.keys(/*info*/ ctx[0].variables);
				internal.validate_each_argument(each_value_1);
				internal.validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key);
				each_blocks_1 = internal.update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div5, internal.destroy_block, create_each_block_1$2, t8, get_each_context_1$2);
			}

			if (dirty & /*dragStart, info*/ 9) {
				each_value = /*info*/ ctx[0].parameters;
				internal.validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div7, t13);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;

			internal.add_render_callback(() => {
				if (!div8_transition) div8_transition = internal.create_bidirectional_transition(div8, transition.slide, { duration: 300, easing: easing.quintOut }, true);
				div8_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			if (!div8_transition) div8_transition = internal.create_bidirectional_transition(div8, transition.slide, { duration: 300, easing: easing.quintOut }, false);
			div8_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div8);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			internal.destroy_each(each_blocks, detaching);
			if (detaching && div8_transition) div8_transition.end();
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(78:4) {#if isDisplaying}",
		ctx
	});

	return block;
}

// (88:12) {#each Object.keys(info.variables) as varId (varId)}
function create_each_block_1$2(key_1, ctx) {
	let div4;
	let div1;
	let div0;
	let t0;
	let input0;
	let input0_value_value;
	let t1;
	let div2;
	let select;
	let option0;
	let option1;
	let select_value_value;
	let t4;
	let div3;
	let input1;
	let input1_value_value;
	let mounted;
	let dispose;

	function change_handler(...args) {
		return /*change_handler*/ ctx[9](/*varId*/ ctx[16], ...args);
	}

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[10](/*varId*/ ctx[16], ...args);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div4 = internal.element("div");
			div1 = internal.element("div");
			div0 = internal.element("div");
			t0 = internal.space();
			input0 = internal.element("input");
			t1 = internal.space();
			div2 = internal.element("div");
			select = internal.element("select");
			option0 = internal.element("option");
			option0.textContent = "String";
			option1 = internal.element("option");
			option1.textContent = "Integer";
			t4 = internal.space();
			div3 = internal.element("div");
			input1 = internal.element("input");
			internal.attr_dev(div0, "class", "drag-var svelte-d9q3dk");
			internal.attr_dev(div0, "draggable", "true");
			internal.add_location(div0, file$d, 91, 24, 2713);
			input0.value = input0_value_value = /*varObj*/ ctx[17].name;
			internal.attr_dev(input0, "type", "text");
			internal.attr_dev(input0, "class", "var-name svelte-d9q3dk");
			internal.add_location(input0, file$d, 92, 24, 2781);
			internal.attr_dev(div1, "class", "flex-1");
			internal.add_location(div1, file$d, 90, 20, 2668);
			option0.__value = "String";
			option0.value = option0.__value;
			internal.add_location(option0, file$d, 94, 124, 3045);
			option1.__value = "Integer";
			option1.value = option1.__value;
			internal.add_location(option1, file$d, 94, 162, 3083);
			internal.add_location(select, file$d, 94, 40, 2961);
			internal.attr_dev(div2, "class", "flex-1");
			internal.add_location(div2, file$d, 94, 20, 2941);
			internal.attr_dev(input1, "type", "text");
			input1.value = input1_value_value = /*varObj*/ ctx[17].value;
			internal.attr_dev(input1, "class", "svelte-d9q3dk");
			internal.add_location(input1, file$d, 95, 40, 3179);
			internal.attr_dev(div3, "class", "flex-1");
			internal.add_location(div3, file$d, 95, 20, 3159);
			internal.attr_dev(div4, "class", "flex w100 space-between var-container");
			internal.add_location(div4, file$d, 89, 16, 2542);
			this.first = div4;
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div4, anchor);
			internal.append_dev(div4, div1);
			internal.append_dev(div1, div0);
			internal.append_dev(div1, t0);
			internal.append_dev(div1, input0);
			internal.append_dev(div4, t1);
			internal.append_dev(div4, div2);
			internal.append_dev(div2, select);
			internal.append_dev(select, option0);
			internal.append_dev(select, option1);
			internal.select_option(select, /*varObj*/ ctx[17].returns);
			internal.append_dev(div4, t4);
			internal.append_dev(div4, div3);
			internal.append_dev(div3, input1);

			if (!mounted) {
				dispose = [
					internal.listen_dev(input0, "change", change_handler, false, false, false),
					internal.listen_dev(select, "change", change_handler_1, false, false, false),
					internal.listen_dev(
						div4,
						"dragstart",
						function () {
							if (internal.is_function(/*dragStart*/ ctx[3]({
								.../*varObj*/ ctx[17],
								refId: /*varId*/ ctx[16]
							}))) /*dragStart*/ ctx[3]({
								.../*varObj*/ ctx[17],
								refId: /*varId*/ ctx[16]
							}).apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*info*/ 1 && input0_value_value !== (input0_value_value = /*varObj*/ ctx[17].name) && input0.value !== input0_value_value) {
				internal.prop_dev(input0, "value", input0_value_value);
			}

			if (dirty & /*info*/ 1 && select_value_value !== (select_value_value = /*varObj*/ ctx[17].returns)) {
				internal.select_option(select, /*varObj*/ ctx[17].returns);
			}

			if (dirty & /*info*/ 1 && input1_value_value !== (input1_value_value = /*varObj*/ ctx[17].value) && input1.value !== input1_value_value) {
				internal.prop_dev(input1, "value", input1_value_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div4);
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$2.name,
		type: "each",
		source: "(88:12) {#each Object.keys(info.variables) as varId (varId)}",
		ctx
	});

	return block;
}

// (105:12) {#each info.parameters as parameter, i}
function create_each_block$4(ctx) {
	let div;
	let span;
	let t0_value = /*parameter*/ ctx[13].name + "";
	let t0;
	let t1;
	let t2;
	let select;
	let option0;
	let option1;
	let select_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = internal.element("div");
			span = internal.element("span");
			t0 = internal.text(t0_value);
			t1 = internal.text(":");
			t2 = internal.space();
			select = internal.element("select");
			option0 = internal.element("option");
			option0.textContent = "String";
			option1 = internal.element("option");
			option1.textContent = "Integer";
			internal.add_location(span, file$d, 106, 16, 3661);
			option0.__value = "String";
			option0.value = option0.__value;
			internal.add_location(option0, file$d, 107, 52, 3745);
			option1.__value = "Integer";
			option1.value = option1.__value;
			internal.add_location(option1, file$d, 107, 90, 3783);
			internal.add_location(select, file$d, 107, 16, 3709);
			internal.attr_dev(div, "draggable", "true");
			internal.attr_dev(div, "class", "flex w100 space-between var-container");
			internal.add_location(div, file$d, 105, 12, 3551);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div, anchor);
			internal.append_dev(div, span);
			internal.append_dev(span, t0);
			internal.append_dev(span, t1);
			internal.append_dev(div, t2);
			internal.append_dev(div, select);
			internal.append_dev(select, option0);
			internal.append_dev(select, option1);
			internal.select_option(select, /*parameter*/ ctx[13].returns);

			if (!mounted) {
				dispose = internal.listen_dev(div, "dragstart", /*dragStart*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*info*/ 1 && t0_value !== (t0_value = /*parameter*/ ctx[13].name + "")) internal.set_data_dev(t0, t0_value);

			if (dirty & /*info*/ 1 && select_value_value !== (select_value_value = /*parameter*/ ctx[13].returns)) {
				internal.select_option(select, /*parameter*/ ctx[13].returns);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div);
			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(105:12) {#each info.parameters as parameter, i}",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let div2;
	let t0;
	let div1;
	let div0;
	let current;
	let mounted;
	let dispose;
	let if_block = /*isDisplaying*/ ctx[1] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			div2 = internal.element("div");
			if (if_block) if_block.c();
			t0 = internal.space();
			div1 = internal.element("div");
			div0 = internal.element("div");
			div0.textContent = "Function Info";
			internal.attr_dev(div0, "class", "tab-toggle svelte-d9q3dk");
			internal.toggle_class(div0, "isDisplaying", /*isDisplaying*/ ctx[1]);
			internal.add_location(div0, file$d, 119, 8, 4083);
			internal.attr_dev(div1, "class", "flex justify-center");
			internal.add_location(div1, file$d, 118, 4, 4041);
			internal.attr_dev(div2, "class", "absolute w100 tab-floater svelte-d9q3dk");
			internal.add_location(div2, file$d, 76, 0, 1918);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div2, anchor);
			if (if_block) if_block.m(div2, null);
			internal.append_dev(div2, t0);
			internal.append_dev(div2, div1);
			internal.append_dev(div1, div0);
			current = true;

			if (!mounted) {
				dispose = [
					internal.listen_dev(div0, "click", /*tabToggle*/ ctx[2], false, false, false),
					internal.listen_dev(div2, "mouseenter", /*stopTimer*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*isDisplaying*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isDisplaying*/ 2) {
						internal.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					internal.transition_in(if_block, 1);
					if_block.m(div2, t0);
				}
			} else if (if_block) {
				internal.group_outros();

				internal.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				internal.check_outros();
			}

			if (dirty & /*isDisplaying*/ 2) {
				internal.toggle_class(div0, "isDisplaying", /*isDisplaying*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div2);
			if (if_block) if_block.d();
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('FunctionInfoTab', slots, []);
	let { info } = $$props;
	let isDisplaying = false;
	let reShowTimer = null;

	function tabToggle(_) {
		$$invalidate(1, isDisplaying = !isDisplaying);
	}

	/**
 * @param {DragEvent} event
 */
	const dragStart = variableDragged => event => {
		const dragData = variableDrag(variableDragged);
		event.dataTransfer.setData('text/json', JSON.stringify(dragData));
		$$invalidate(1, isDisplaying = false);
	}; // Will auto-drop the menu after you've dropped a variable or parameter
	// document.addEventListener('drop', functionInfoDrop, true);

	function functionInfoDrop(event) {
		$$invalidate(1, isDisplaying = true);
		document.removeEventListener('drop', functionInfoDrop, true);
		reShowTimer = setTimeout(tabToggle, 1200);
	}

	function addVariable(_) {
		$$invalidate(
			0,
			info.variables = {
				...info.variables,
				[uuid.v4()]: {
					"name": "newVar",
					"returns": "String",
					"value": ""
				}
			},
			info
		);
	}

	function addParameter(_) {
		$$invalidate(0, info.parameters = [...info.parameters, { "name": "newParam", "returns": "String" }], info);
	}

	function stopTimer(_) {
		if (reShowTimer) {
			clearTimeout(reShowTimer);
			reShowTimer = null;
		}
	}

	function changeVarName(varId, newName) {
		$$invalidate(0, info.variables[varId] = { ...info.variables[varId], name: newName }, info);
	}

	function varTypeChange(event, id) {
		$$invalidate(
			0,
			info.variables[id] = {
				...info.variables[id],
				"returns": event.target.value
			},
			info
		);
	}

	const writable_props = ['info'];

	Object_1$3.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FunctionInfoTab> was created with unknown prop '${key}'`);
	});

	const change_handler = (varId, e) => changeVarName(varId, e.target.value);
	const change_handler_1 = (varId, event) => varTypeChange(event, varId);

	$$self.$$set = $$props => {
		if ('info' in $$props) $$invalidate(0, info = $$props.info);
	};

	$$self.$capture_state = () => ({
		slide: transition.slide,
		quintOut: easing.quintOut,
		variableDrag,
		uuidv4: uuid.v4,
		info,
		isDisplaying,
		reShowTimer,
		tabToggle,
		dragStart,
		functionInfoDrop,
		addVariable,
		addParameter,
		stopTimer,
		changeVarName,
		varTypeChange
	});

	$$self.$inject_state = $$props => {
		if ('info' in $$props) $$invalidate(0, info = $$props.info);
		if ('isDisplaying' in $$props) $$invalidate(1, isDisplaying = $$props.isDisplaying);
		if ('reShowTimer' in $$props) reShowTimer = $$props.reShowTimer;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		info,
		isDisplaying,
		tabToggle,
		dragStart,
		addVariable,
		addParameter,
		stopTimer,
		changeVarName,
		varTypeChange,
		change_handler,
		change_handler_1
	];
}

class FunctionInfoTab extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$d, create_fragment$d, internal.safe_not_equal, { info: 0 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FunctionInfoTab",
			options,
			id: create_fragment$d.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*info*/ ctx[0] === undefined && !('info' in props)) {
			console.warn("<FunctionInfoTab> was created without expected prop 'info'");
		}
	}

	get info() {
		throw new Error("<FunctionInfoTab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<FunctionInfoTab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/** @type {TypeDefinitionWrapper} */
const typeDefs =  {
    "StringUtil": {
        "concat": {
            "args": [
                "String",
                "String"
            ],
            "infiniteArgs": true,
            "returns": "String"
        },
        "trim": {
            "args": [
                "String"
            ],
            "inifiniteArgs": false,
            "returns": "String"
        },
        "length": {
            "args": [
                "String"
            ],
            "infiniteArgs": false,
            "returns": "Integer"
        },
        "fromInt": {
            "args": [
                "Integer"
            ],
            "infiniteArgs": false,
            "returns": "String"
        },
        "substring": {
            "args": [
                "Integer",
                "String"
            ],
            "infiniteArgs": false,
            "returns": "String"
        }
    },
    "String": {
        "concat": {
            "args": [
                "String"
            ],
            "infiniteArgs": true,
            "returns": "String"
        },
        "trim": {
            "args": [],
            "inifiniteArgs": false,
            "returns": "String"
        },
        "prepend": {
            "args": [
                "String"
            ],
            "infiniteArgs": false,
            "returns": "String"
        },
        "length": {
            "args": [],
            "infiniteArgs": false,
            "returns": "Integer"
        }
    },
    "Integer": {
        "parse": {
            "args": [
                "String"
            ],
            "infiniteArgs": false,
            "returns": "Integer"
        },
        "add": {
            "args": [
                "Integer"
            ],
            "infiniteArgs": true,
            "returns": "Integer"
        },
        "subtract": {
            "args": [
                "Integer"
            ],
            "infiniteArgs": true,
            "returns": "Integer"
        },
        "toString": {
            "args": [],
            "infiniteArgs": false,
            "returns": "String"
        }
    },
    "List": {
        "join": {
            "args": [
                "String"
            ],
            "infiniteArgs": false,
            "returns": "String"
        }
    }
};

/** @type {NodeTemplates} */
const nodeTemplates = {
    StringUtil: function(method = "concat") {
        const methodDefinition = typeDefs['StringUtil'][method];
        const definitionArgs = methodDefinition.args;

        return {
            type: "UtilityCallExpression",
            utilityName: "StringUtil",
            utilityMethod: method,
            arguments: definitionArgs.map((argType) => this[argType + "Literal"]({})),
            returns: methodDefinition.returns
        };
    },
    varCallExpression: function({ method, returns, variable }) {
        const methodDefinition = typeDefs[variable.returns][method];
        const definitionArgs = methodDefinition.args;

        return {
            type: "VarCallExpression",
            variable: {...variable},
            method,
            arguments: definitionArgs.map((argType) => this[argType + "Literal"]({})),
            returns
        };
    },
    expression: () => {
        const newUuid = uuid.v4();
        return {
            type: "ExpressionStatement",
            id: newUuid,
            expression: null
        };
    },
    variableAssignment: ({ refId, returns }) => ({
        type: "AssignmentExpression",
        left: {
            type: "VarIdentifier",
            refId,
            returns
        },
        right: null
    }),
    variableIdentifier: ({ refId, returns }) => ({
        type: "VarIdentifier",
        refId,
        returns
    }),
    // Capitalizing because it matches the 'type' field in the AST
    StringLiteral: ({ value = "" }) => ({
        type: "StringLiteral",
        value: value,
        returns: "String"
    }),
    // Capitalizing because it matches the 'type' field in the AST
    IntegerLiteral: ({ value = 0 }) => ({
        type: "IntegerLiteral",
        value,
        returns: "Integer"
    })
};

const getDragData = (event) => JSON.parse(event.dataTransfer.getData('text/json'));


const dragDataTypeMatchesContext = (dragData, contextType) => {
    if ((dragData.data?.returns ?? false) && contextType !== undefined) {
        if (dragData.data.returns !== contextType) {
            return false;
        }
        return true;
    }
};


// This finds a method for the string util that matches the context's type, if any,
// so the drop data template can be created with that method as the starting, selected method
const findReturnTypeMatch = (utilType) => (contextType) => {
    for (let methodName of Object.keys(typeDefs[utilType])) {
        const method = typeDefs[utilType][methodName];
        if (method.returns === contextType) {
            return methodName;
        }
    }
    return null;
};
const findStringUtilTypeMatch = findReturnTypeMatch("StringUtil");


const wrapWithExpression = (node) => {
    const expr = nodeTemplates.expression();
    expr.expression = node;
    return expr;
};


/**
 * @param {Object} dragData - The DragEvent data parsed into an object
 * @param {string} type - Data type
 * @returns {?Object.<string, *>} Returns either null or the ast node to be created from dropping this stringUtil
 */
const stringUtilFromTypedContext = (dragData, contextType) => {
    const methodName = findStringUtilTypeMatch(contextType);
    if (methodName === null) return null;
    return nodeTemplates.StringUtil(methodName);
};


/**
 * Creates an AST node for dropping a variable into a typed context
 * @param {{ name: string, refId: string, returns: string, value: string }} dragData 
 * @param {string} contextType Data type that is required by the variable's parent, a.k.a the contextual data type
 * @returns {Object}
 */
const variableFromTypedContext = (dragData, contextType) => {
    const variableTypeMatchesContext = dragDataTypeMatchesContext(dragData, contextType);
    
    if (variableTypeMatchesContext) {
        return nodeTemplates.variableIdentifier(dragData.data);
    }

    const method = findReturnTypeMatch(dragData.data.returns)(contextType);
    if (method === null) alert("Types don't match and no methods exist to match the type");
    
    return method !== null
        ? nodeTemplates.varCallExpression({
            method: method,
            returns: contextType,
            variable: nodeTemplates.variableIdentifier({ refId: dragData.data.refId, returns: dragData.data.returns })
        })
        : null;
};

const noNode = (dragData, contextType) => null;


const dropContextMap = {
    // dragType
    variable: {
        // context name
        flow: (dragData, contextType) => wrapWithExpression(nodeTemplates.variableAssignment(dragData.data)),
        expression: (dragData, contextType) => nodeTemplates.variableAssignment(dragData.data),
        assignment: variableFromTypedContext,
        argument: variableFromTypedContext
    },
    StringUtil: {
        flow: noNode,
        expression: noNode,
        assignment: stringUtilFromTypedContext,
        argument: stringUtilFromTypedContext
    },
    expression: {
        flow: (dragData, contextType) => nodeTemplates.expression(),
        expression: noNode,
        assignment: noNode,
        argument: noNode
    },
    moveExpression: {
        flow: (dragData, contextType) => ({ moveData: dragData.node, currentIndex: dragData.currentIndex }),
        expression: (dragData, contextType) => ({ moveData: dragData.node, currentIndex: dragData.currentIndex }),
        assignment: noNode,
        argument: noNode
    }
};

/**
 * @callback stateChangeCallback
 * @param {Object.<string, *>} node - The ast node being created from the drop that occurred or null
 * if nothing should happen
 */
/**
 * @callback dragEventHandler
 * @param {DragEvent} dragEvent The DragEvent passed from the original event handler
 */
/**
 * @param {Object} dropConfig
 * @param {string} dropConfig.contextName The name of the component in which the drop event occurs. If I
 * drop in something into an assigment, the context would be 'assignment'. See the structure above
 * in 'drag_and_drop_handlers.js'
 * @param {string} [dropConfig.contextType] The data type of the context component
 * @param {stateChangeCallback} dropConfig.stateChangeCallback What gets called to modify state once the drop
 * has occurred and an ast node has been created and passed to this callback
 * @returns {dragEventHandler}
 */
const flowDropHandler = ({ contextName, contextType, stateChangeCallback }) => (dragEvent) => {
    const dragData = getDragData(dragEvent);

    const node = dropContextMap[dragData.dragType][contextName](dragData, contextType);
    
    stateChangeCallback(node);
};

const var1 = uuid.v4();
const var2 = uuid.v4();

const mockData = {
    "main": {
        "info": {
            "variables": {
                [var1]: {
                    "name": "aStr",
                    "value": "",
                    "returns": "String"
                },
                [var2]: {
                    "name": "aNum",
                    "value": 0,
                    "returns": "Integer"
                }
            },
            "parameters": [],
        },
        "body": [
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": {
                    "type": "AssignmentExpression",
                    "left": {
                        "type": "VarIdentifier",
                        "refId": var1,
                        "returns": "String"
                    },
                    "right": {
                        "type": "UtilityCallExpression",
                        "utilityName": "StringUtil",
                        "utilityMethod": "concat",
                        "arguments": [
                            {
                                "type": "StringLiteral",
                                "value": "A long string teehee",
                                "returns": "String"
                            },
                            {
                                "type": "VarIdentifier",
                                "refId": var1,
                                "returns": "String"
                            }
                        ],
                        "returns": "String"
                    }
                }
            },
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": {
                    "type": "AssignmentExpression",
                    "left": {
                        "type": "VarIdentifier",
                        "refId": var1,
                        "returns": "String"
                    },
                    "right": {
                        "type": "VarCallExpression",
                        "variable": {
                            "type": "VarIdentifier",
                            "refId": var1,
                            "returns": "String"
                        },
                        "method": "concat",
                        "arguments": [
                            {
                                "type": "StringLiteral",
                                "value": "A long string teehee",
                                "returns": "String"
                            }
                        ],
                        "returns": "String"
                    }
                }
            },
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": {
                    "type": "AssignmentExpression",
                    "left": {
                        "type": "VarIdentifier",
                        "refId": var2,
                        "returns": "Integer"
                    },
                    "right": {
                        "type": "UtilityCallExpression",
                        "utilityName": "StringUtil",
                        "utilityMethod": "length",
                        "arguments": [
                            {
                                "type": "StringLiteral",
                                "value": "Counting the length of the string",
                                "returns": "String"
                            }
                        ],
                        "returns": "Integer"
                    }
                }
            },
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": null
            },
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": null
            },
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": null
            },
            {
                "type": "ExpressionStatement",
                "id": uuid.v4(),
                "expression": null
            },
        ]
    }
};

const ast = store.writable(
    mockData
);

/* src/components/ClearNodeProp.svelte generated by Svelte v3.46.4 */

const file$c = "src/components/ClearNodeProp.svelte";

function create_fragment$c(ctx) {
	let button;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = internal.element("button");
			button.textContent = "Clear";
			internal.attr_dev(button, "class", "delete-btn");
			internal.add_location(button, file$c, 4, 0, 44);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, button, anchor);

			if (!mounted) {
				dispose = internal.listen_dev(
					button,
					"click",
					function () {
						if (internal.is_function(/*onClick*/ ctx[0])) /*onClick*/ ctx[0].apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('ClearNodeProp', slots, []);
	let { onClick } = $$props;
	const writable_props = ['onClick'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClearNodeProp> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('onClick' in $$props) $$invalidate(0, onClick = $$props.onClick);
	};

	$$self.$capture_state = () => ({ onClick });

	$$self.$inject_state = $$props => {
		if ('onClick' in $$props) $$invalidate(0, onClick = $$props.onClick);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [onClick];
}

class ClearNodeProp extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$c, create_fragment$c, internal.safe_not_equal, { onClick: 0 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClearNodeProp",
			options,
			id: create_fragment$c.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*onClick*/ ctx[0] === undefined && !('onClick' in props)) {
			console.warn("<ClearNodeProp> was created without expected prop 'onClick'");
		}
	}

	get onClick() {
		throw new Error("<ClearNodeProp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onClick(value) {
		throw new Error("<ClearNodeProp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/DragHandle.svelte generated by Svelte v3.46.4 */

const file$b = "src/components/DragHandle.svelte";

function create_fragment$b(ctx) {
	let div;

	const block = {
		c: function create() {
			div = internal.element("div");
			internal.attr_dev(div, "class", "drag-handle svelte-1tyonyw");
			internal.attr_dev(div, "draggable", "true");
			internal.add_location(div, file$b, 1, 0, 1);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div, anchor);
		},
		p: internal.noop,
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('DragHandle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DragHandle> was created with unknown prop '${key}'`);
	});

	return [];
}

class DragHandle extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$b, create_fragment$b, internal.safe_not_equal, {});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DragHandle",
			options,
			id: create_fragment$b.name
		});
	}
}

/* src/components/flow_objects/ExpressionStatement.svelte generated by Svelte v3.46.4 */
const file$a = "src/components/flow_objects/ExpressionStatement.svelte";

// (84:12) {#if nodeData?.expression ?? false}
function create_if_block_1$2(ctx) {
	let clearnodeprop;
	let current;

	clearnodeprop = new ClearNodeProp({
			props: { onClick: /*func*/ ctx[13] },
			$$inline: true
		});

	const block = {
		c: function create() {
			internal.create_component(clearnodeprop.$$.fragment);
		},
		m: function mount(target, anchor) {
			internal.mount_component(clearnodeprop, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const clearnodeprop_changes = {};
			if (dirty & /*nodeData*/ 1) clearnodeprop_changes.onClick = /*func*/ ctx[13];
			clearnodeprop.$set(clearnodeprop_changes);
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(clearnodeprop.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(clearnodeprop.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			internal.destroy_component(clearnodeprop, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(84:12) {#if nodeData?.expression ?? false}",
		ctx
	});

	return block;
}

// (96:8) {:else}
function create_else_block$3(ctx) {
	let p;

	const block = {
		c: function create() {
			p = internal.element("p");
			p.textContent = "Drag an action here";
			internal.attr_dev(p, "class", "dull-text");
			internal.add_location(p, file$a, 96, 12, 2947);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, p, anchor);
		},
		p: internal.noop,
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(p);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(96:8) {:else}",
		ctx
	});

	return block;
}

// (90:8) {#if nodeData && nodeData.expression !== null}
function create_if_block$4(ctx) {
	let switch_instance;
	let updating_nodeData;
	let switch_instance_anchor;
	let current;

	function switch_instance_nodeData_binding(value) {
		/*switch_instance_nodeData_binding*/ ctx[15](value);
	}

	var switch_value = constructors[/*nodeData*/ ctx[0].expression.type];

	function switch_props(ctx) {
		let switch_instance_props = {
			nodePath: /*nodePath*/ ctx[2] + ".expression"
		};

		if (/*nodeData*/ ctx[0].expression !== void 0) {
			switch_instance_props.nodeData = /*nodeData*/ ctx[0].expression;
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
	}

	const block = {
		c: function create() {
			if (switch_instance) internal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = internal.empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				internal.mount_component(switch_instance, target, anchor);
			}

			internal.insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = {};
			if (dirty & /*nodePath*/ 4) switch_instance_changes.nodePath = /*nodePath*/ ctx[2] + ".expression";

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				switch_instance_changes.nodeData = /*nodeData*/ ctx[0].expression;
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			if (switch_value !== (switch_value = constructors[/*nodeData*/ ctx[0].expression.type])) {
				if (switch_instance) {
					internal.group_outros();
					const old_component = switch_instance;

					internal.transition_out(old_component.$$.fragment, 1, 0, () => {
						internal.destroy_component(old_component, 1);
					});

					internal.check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
					internal.create_component(switch_instance.$$.fragment);
					internal.transition_in(switch_instance.$$.fragment, 1);
					internal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) internal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) internal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(switch_instance_anchor);
			if (switch_instance) internal.destroy_component(switch_instance, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(90:8) {#if nodeData && nodeData.expression !== null}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let div3;
	let div1;
	let draghandle;
	let t0;
	let div0;
	let t1;
	let button;
	let t3;
	let current_block_type_index;
	let if_block1;
	let t4;
	let div2;
	let current;
	let mounted;
	let dispose;
	draghandle = new DragHandle({ $$inline: true });
	let if_block0 = (/*nodeData*/ ctx[0]?.expression ?? false) && create_if_block_1$2(ctx);
	const if_block_creators = [create_if_block$4, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nodeData*/ ctx[0] && /*nodeData*/ ctx[0].expression !== null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div3 = internal.element("div");
			div1 = internal.element("div");
			internal.create_component(draghandle.$$.fragment);
			t0 = internal.space();
			div0 = internal.element("div");
			if (if_block0) if_block0.c();
			t1 = internal.space();
			button = internal.element("button");
			button.textContent = "Delete";
			t3 = internal.space();
			if_block1.c();
			t4 = internal.space();
			div2 = internal.element("div");
			internal.attr_dev(button, "class", "delete-btn");
			internal.add_location(button, file$a, 86, 12, 2544);
			internal.attr_dev(div0, "class", "flex w100");
			internal.add_location(div0, file$a, 82, 8, 2364);
			internal.attr_dev(div1, "tabindex", "0");
			internal.attr_dev(div1, "class", "expression-container svelte-5e8c7l");
			internal.add_location(div1, file$a, 74, 4, 1986);
			internal.attr_dev(div2, "class", "line-down-box svelte-5e8c7l");
			internal.toggle_class(div2, "insert-drag-over", /*isOverInsertSpot*/ ctx[3]);
			internal.add_location(div2, file$a, 99, 4, 3021);
			internal.attr_dev(div3, "class", "svelte-5e8c7l");
			internal.toggle_class(div3, "beingDragged", /*beingDragged*/ ctx[4]);
			internal.add_location(div3, file$a, 73, 0, 1957);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div3, anchor);
			internal.append_dev(div3, div1);
			internal.mount_component(draghandle, div1, null);
			internal.append_dev(div1, t0);
			internal.append_dev(div1, div0);
			if (if_block0) if_block0.m(div0, null);
			internal.append_dev(div0, t1);
			internal.append_dev(div0, button);
			internal.append_dev(div1, t3);
			if_blocks[current_block_type_index].m(div1, null);
			internal.append_dev(div3, t4);
			internal.append_dev(div3, div2);
			current = true;

			if (!mounted) {
				dispose = [
					internal.listen_dev(button, "click", /*click_handler*/ ctx[14], false, false, false),
					internal.listen_dev(div1, "dragover", internal.prevent_default(dragOverHandler$1), false, true, false),
					internal.listen_dev(
						div1,
						"drop",
						internal.stop_propagation(internal.prevent_default(flowDropHandler({
							contextName: 'expression',
							stateChangeCallback: /*dropModify*/ ctx[9]
						}))),
						false,
						true,
						true
					),
					internal.listen_dev(div1, "dragstart", internal.stop_propagation(/*handleDragStart*/ ctx[11]), false, false, true),
					internal.listen_dev(div1, "dragend", internal.stop_propagation(/*checkDropCancel*/ ctx[12]), false, false, true),
					internal.listen_dev(div2, "dragover", internal.prevent_default(insertDragOverHandler), false, true, false),
					internal.listen_dev(div2, "dragenter", internal.prevent_default(/*insertDragEnter*/ ctx[6]), false, true, false),
					internal.listen_dev(div2, "dragleave", internal.prevent_default(/*insertDragLeave*/ ctx[7]), false, true, false),
					internal.listen_dev(
						div2,
						"drop",
						internal.stop_propagation(internal.prevent_default(flowDropHandler({
							contextName: 'flow',
							stateChangeCallback: /*insertDrop*/ ctx[10]
						}))),
						false,
						true,
						true
					),
					internal.listen_dev(div2, "drop", internal.stop_propagation(internal.prevent_default(/*removeInsertHover*/ ctx[8])), false, true, true)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*nodeData*/ ctx[0]?.expression ?? false) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*nodeData*/ 1) {
						internal.transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1$2(ctx);
					if_block0.c();
					internal.transition_in(if_block0, 1);
					if_block0.m(div0, t1);
				}
			} else if (if_block0) {
				internal.group_outros();

				internal.transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				internal.check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				internal.group_outros();

				internal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				internal.check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				internal.transition_in(if_block1, 1);
				if_block1.m(div1, null);
			}

			if (dirty & /*isOverInsertSpot*/ 8) {
				internal.toggle_class(div2, "insert-drag-over", /*isOverInsertSpot*/ ctx[3]);
			}

			if (dirty & /*beingDragged*/ 16) {
				internal.toggle_class(div3, "beingDragged", /*beingDragged*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(draghandle.$$.fragment, local);
			internal.transition_in(if_block0);
			internal.transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(draghandle.$$.fragment, local);
			internal.transition_out(if_block0);
			internal.transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div3);
			internal.destroy_component(draghandle);
			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function dragOverHandler$1(event) {
	
} // do something like change cursor

function insertDragOverHandler(event) {
	
} // something

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('ExpressionStatement', slots, []);
	let { accessor } = $$props;
	let { nodeData } = $$props;
	let { nodePath } = $$props;
	let isOverInsertSpot = false;
	let beingDragged = false;
	const dispatch = svelte.createEventDispatcher();

	function insertDragEnter(event) {
		$$invalidate(3, isOverInsertSpot = true);
	}

	function insertDragLeave(event) {
		$$invalidate(3, isOverInsertSpot = false);
	}

	function removeInsertHover(event) {
		$$invalidate(3, isOverInsertSpot = false);
	}

	function dropModify(node) {
		if (node.currentIndex !== undefined) {
			dispatch('delete', node.currentIndex);
			node = node.moveData;
		}

		if (node.type === 'ExpressionStatement') $$invalidate(0, nodeData.expression = node.expression, nodeData); else $$invalidate(0, nodeData.expression = node, nodeData);
	}

	function insertDrop(node) {
		if (node === null) {
			return;
		}

		if (node.currentIndex !== undefined) {
			dispatch('moveExpression', { ...node, newIndex: accessor + 1 });
			return;
		}

		dispatch('insertAfter', node);
	}

	/** @type {DragHandler} */
	function handleDragStart(event) {
		const dragData = moveExpressionDrag(nodeData, accessor);
		event.dataTransfer.setData('text/json', JSON.stringify(dragData));
		$$invalidate(4, beingDragged = true);
	}

	/** @type {DragHandler} */
	function checkDropCancel(event) {
		$$invalidate(4, beingDragged = false);
	}

	const writable_props = ['accessor', 'nodeData', 'nodePath'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExpressionStatement> was created with unknown prop '${key}'`);
	});

	const func = _ => $$invalidate(0, nodeData.expression = null, nodeData);
	const click_handler = () => dispatch('delete', accessor);

	function switch_instance_nodeData_binding(value) {
		if ($$self.$$.not_equal(nodeData.expression, value)) {
			nodeData.expression = value;
			$$invalidate(0, nodeData);
		}
	}

	$$self.$$set = $$props => {
		if ('accessor' in $$props) $$invalidate(1, accessor = $$props.accessor);
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(2, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher: svelte.createEventDispatcher,
		flowDropHandler,
		constructors,
		ClearNodeProp,
		DragHandle,
		moveExpressionDrag,
		accessor,
		nodeData,
		nodePath,
		isOverInsertSpot,
		beingDragged,
		dispatch,
		dragOverHandler: dragOverHandler$1,
		insertDragOverHandler,
		insertDragEnter,
		insertDragLeave,
		removeInsertHover,
		dropModify,
		insertDrop,
		handleDragStart,
		checkDropCancel
	});

	$$self.$inject_state = $$props => {
		if ('accessor' in $$props) $$invalidate(1, accessor = $$props.accessor);
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(2, nodePath = $$props.nodePath);
		if ('isOverInsertSpot' in $$props) $$invalidate(3, isOverInsertSpot = $$props.isOverInsertSpot);
		if ('beingDragged' in $$props) $$invalidate(4, beingDragged = $$props.beingDragged);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		nodeData,
		accessor,
		nodePath,
		isOverInsertSpot,
		beingDragged,
		dispatch,
		insertDragEnter,
		insertDragLeave,
		removeInsertHover,
		dropModify,
		insertDrop,
		handleDragStart,
		checkDropCancel,
		func,
		click_handler,
		switch_instance_nodeData_binding
	];
}

class ExpressionStatement extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$a, create_fragment$a, internal.safe_not_equal, { accessor: 1, nodeData: 0, nodePath: 2 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ExpressionStatement",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*accessor*/ ctx[1] === undefined && !('accessor' in props)) {
			console.warn("<ExpressionStatement> was created without expected prop 'accessor'");
		}

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<ExpressionStatement> was created without expected prop 'nodeData'");
		}

		if (/*nodePath*/ ctx[2] === undefined && !('nodePath' in props)) {
			console.warn("<ExpressionStatement> was created without expected prop 'nodePath'");
		}
	}

	get accessor() {
		throw new Error("<ExpressionStatement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accessor(value) {
		throw new Error("<ExpressionStatement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeData() {
		throw new Error("<ExpressionStatement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<ExpressionStatement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<ExpressionStatement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<ExpressionStatement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Argument.svelte generated by Svelte v3.46.4 */
const file$9 = "src/components/Argument.svelte";

function create_fragment$9(ctx) {
	let div1;
	let p;
	let span;
	let t0;
	let t1;
	let t2;
	let div0;
	let div0_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = internal.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	const block = {
		c: function create() {
			div1 = internal.element("div");
			p = internal.element("p");
			span = internal.element("span");
			t0 = internal.text(/*returnType*/ ctx[1]);
			t1 = internal.text(" >");
			t2 = internal.space();
			div0 = internal.element("div");
			if (default_slot) default_slot.c();
			internal.attr_dev(span, "class", "small-text");
			internal.add_location(span, file$9, 19, 44, 461);
			internal.attr_dev(p, "class", "gt-symbol svelte-1w5dope");
			internal.add_location(p, file$9, 19, 4, 421);
			internal.attr_dev(div0, "class", div0_class_value = "flex-1 argument-container " + /*argLevelClass*/ ctx[2] + " svelte-1w5dope");
			internal.add_location(div0, file$9, 20, 4, 520);
			internal.attr_dev(div1, "class", "flex wrapper svelte-1w5dope");
			internal.add_location(div1, file$9, 18, 0, 390);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div1, anchor);
			internal.append_dev(div1, p);
			internal.append_dev(p, span);
			internal.append_dev(span, t0);
			internal.append_dev(p, t1);
			internal.append_dev(div1, t2);
			internal.append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					internal.listen_dev(
						p,
						"click",
						function () {
							if (internal.is_function(/*onClear*/ ctx[0])) /*onClear*/ ctx[0].apply(this, arguments);
						},
						false,
						false,
						false
					),
					internal.listen_dev(div0, "drop", internal.stop_propagation(/*drop_handler*/ ctx[7]), false, false, true),
					internal.listen_dev(div0, "dragover", dragover_handler$1, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			if (!current || dirty & /*returnType*/ 2) internal.set_data_dev(t0, /*returnType*/ ctx[1]);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					internal.update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? internal.get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: internal.get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*argLevelClass*/ 4 && div0_class_value !== (div0_class_value = "flex-1 argument-container " + /*argLevelClass*/ ctx[2] + " svelte-1w5dope")) {
				internal.attr_dev(div0, "class", div0_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const dragover_handler$1 = () => {
	
};

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('Argument', slots, ['default']);
	let { argLevel } = $$props;

	let { onClear = () => {
		
	} } = $$props;

	let { returnType } = $$props;
	let argLevelClass = "level-1n";

	if (argLevel % 3 === 0) {
		argLevelClass = "level-3n";
	} else if (argLevel % 3 === 2) {
		argLevelClass = "level-2n";
	}

	const dispatch = svelte.createEventDispatcher();
	const writable_props = ['argLevel', 'onClear', 'returnType'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Argument> was created with unknown prop '${key}'`);
	});

	const drop_handler = event => dispatch('innerDrop', event);

	$$self.$$set = $$props => {
		if ('argLevel' in $$props) $$invalidate(4, argLevel = $$props.argLevel);
		if ('onClear' in $$props) $$invalidate(0, onClear = $$props.onClear);
		if ('returnType' in $$props) $$invalidate(1, returnType = $$props.returnType);
		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher: svelte.createEventDispatcher,
		argLevel,
		onClear,
		returnType,
		argLevelClass,
		dispatch
	});

	$$self.$inject_state = $$props => {
		if ('argLevel' in $$props) $$invalidate(4, argLevel = $$props.argLevel);
		if ('onClear' in $$props) $$invalidate(0, onClear = $$props.onClear);
		if ('returnType' in $$props) $$invalidate(1, returnType = $$props.returnType);
		if ('argLevelClass' in $$props) $$invalidate(2, argLevelClass = $$props.argLevelClass);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		onClear,
		returnType,
		argLevelClass,
		dispatch,
		argLevel,
		$$scope,
		slots,
		drop_handler
	];
}

class Argument extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$9, create_fragment$9, internal.safe_not_equal, { argLevel: 4, onClear: 0, returnType: 1 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Argument",
			options,
			id: create_fragment$9.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*argLevel*/ ctx[4] === undefined && !('argLevel' in props)) {
			console.warn("<Argument> was created without expected prop 'argLevel'");
		}

		if (/*returnType*/ ctx[1] === undefined && !('returnType' in props)) {
			console.warn("<Argument> was created without expected prop 'returnType'");
		}
	}

	get argLevel() {
		throw new Error("<Argument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set argLevel(value) {
		throw new Error("<Argument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onClear() {
		throw new Error("<Argument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onClear(value) {
		throw new Error("<Argument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get returnType() {
		throw new Error("<Argument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set returnType(value) {
		throw new Error("<Argument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/UtilityCallExpression.svelte generated by Svelte v3.46.4 */

const { Object: Object_1$2 } = internal.globals;
const file$8 = "src/components/flow_objects/UtilityCallExpression.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i];
	child_ctx[16] = list;
	child_ctx[17] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

// (52:12) {#each Object.keys(utilities).filter(matchParentTypeFilter) as method}
function create_each_block_1$1(ctx) {
	let option;
	let t_value = /*method*/ ctx[18] + "";
	let t;
	let option_selected_value;

	const block = {
		c: function create() {
			option = internal.element("option");
			t = internal.text(t_value);
			option.__value = /*method*/ ctx[18];
			option.value = option.__value;
			option.selected = option_selected_value = /*method*/ ctx[18] === /*nodeData*/ ctx[0].utilityMethod;
			internal.add_location(option, file$8, 52, 16, 1769);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, option, anchor);
			internal.append_dev(option, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*nodeData*/ 1 && option_selected_value !== (option_selected_value = /*method*/ ctx[18] === /*nodeData*/ ctx[0].utilityMethod)) {
				internal.prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(option);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(52:12) {#each Object.keys(utilities).filter(matchParentTypeFilter) as method}",
		ctx
	});

	return block;
}

// (68:16) {:else}
function create_else_block$2(ctx) {
	let switch_instance;
	let updating_nodeData;
	let switch_instance_anchor;
	let current;

	function switch_instance_nodeData_binding(value) {
		/*switch_instance_nodeData_binding*/ ctx[12](value, /*argument*/ ctx[15], /*each_value*/ ctx[16], /*i*/ ctx[17]);
	}

	var switch_value = constructors[/*argument*/ ctx[15].type];

	function switch_props(ctx) {
		let switch_instance_props = {
			argLevel: /*argLevel*/ ctx[1] + 1,
			isArgument: true,
			contextType: /*argument*/ ctx[15].returns,
			nodePath: /*nodePath*/ ctx[2] + ".arguments." + /*i*/ ctx[17]
		};

		if (/*argument*/ ctx[15] !== void 0) {
			switch_instance_props.nodeData = /*argument*/ ctx[15];
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
	}

	const block = {
		c: function create() {
			if (switch_instance) internal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = internal.empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				internal.mount_component(switch_instance, target, anchor);
			}

			internal.insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const switch_instance_changes = {};
			if (dirty & /*argLevel*/ 2) switch_instance_changes.argLevel = /*argLevel*/ ctx[1] + 1;
			if (dirty & /*nodeData*/ 1) switch_instance_changes.contextType = /*argument*/ ctx[15].returns;
			if (dirty & /*nodePath, nodeData*/ 5) switch_instance_changes.nodePath = /*nodePath*/ ctx[2] + ".arguments." + /*i*/ ctx[17];

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				switch_instance_changes.nodeData = /*argument*/ ctx[15];
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			if (switch_value !== (switch_value = constructors[/*argument*/ ctx[15].type])) {
				if (switch_instance) {
					internal.group_outros();
					const old_component = switch_instance;

					internal.transition_out(old_component.$$.fragment, 1, 0, () => {
						internal.destroy_component(old_component, 1);
					});

					internal.check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
					internal.create_component(switch_instance.$$.fragment);
					internal.transition_in(switch_instance.$$.fragment, 1);
					internal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) internal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) internal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(switch_instance_anchor);
			if (switch_instance) internal.destroy_component(switch_instance, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(68:16) {:else}",
		ctx
	});

	return block;
}

// (66:16) {#if argument.type === "UtilityCallExpression"}
function create_if_block$3(ctx) {
	let utilitycallexpression;
	let updating_nodeData;
	let current;

	function utilitycallexpression_nodeData_binding(value) {
		/*utilitycallexpression_nodeData_binding*/ ctx[11](value, /*argument*/ ctx[15], /*each_value*/ ctx[16], /*i*/ ctx[17]);
	}

	let utilitycallexpression_props = {
		argLevel: /*argLevel*/ ctx[1] + 1,
		isArgument: true,
		contextType: /*argument*/ ctx[15].returns,
		nodePath: /*nodePath*/ ctx[2] + ".arguments." + /*i*/ ctx[17]
	};

	if (/*argument*/ ctx[15] !== void 0) {
		utilitycallexpression_props.nodeData = /*argument*/ ctx[15];
	}

	utilitycallexpression = new UtilityCallExpression({
			props: utilitycallexpression_props,
			$$inline: true
		});

	internal.binding_callbacks.push(() => internal.bind(utilitycallexpression, 'nodeData', utilitycallexpression_nodeData_binding));

	const block = {
		c: function create() {
			internal.create_component(utilitycallexpression.$$.fragment);
		},
		m: function mount(target, anchor) {
			internal.mount_component(utilitycallexpression, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const utilitycallexpression_changes = {};
			if (dirty & /*argLevel*/ 2) utilitycallexpression_changes.argLevel = /*argLevel*/ ctx[1] + 1;
			if (dirty & /*nodeData*/ 1) utilitycallexpression_changes.contextType = /*argument*/ ctx[15].returns;
			if (dirty & /*nodePath, nodeData*/ 5) utilitycallexpression_changes.nodePath = /*nodePath*/ ctx[2] + ".arguments." + /*i*/ ctx[17];

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				utilitycallexpression_changes.nodeData = /*argument*/ ctx[15];
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			utilitycallexpression.$set(utilitycallexpression_changes);
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(utilitycallexpression.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(utilitycallexpression.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			internal.destroy_component(utilitycallexpression, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(66:16) {#if argument.type === \\\"UtilityCallExpression\\\"}",
		ctx
	});

	return block;
}

// (60:12) <Argument {argLevel}                  on:innerDrop={(event) => flowDropHandler({ contextName: 'argument', contextType: argument.returns, stateChangeCallback: addArgument(i) })(event.detail)}                 onClear={() => onClear(i, argument)}                 returnType={argument.returns}>
function create_default_slot$1(ctx) {
	let clearnodeprop;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;

	function func(...args) {
		return /*func*/ ctx[10](/*i*/ ctx[17], /*argument*/ ctx[15], ...args);
	}

	clearnodeprop = new ClearNodeProp({ props: { onClick: func }, $$inline: true });
	const if_block_creators = [create_if_block$3, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*argument*/ ctx[15].type === "UtilityCallExpression") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			internal.create_component(clearnodeprop.$$.fragment);
			t0 = internal.space();
			if_block.c();
			t1 = internal.space();
		},
		m: function mount(target, anchor) {
			internal.mount_component(clearnodeprop, target, anchor);
			internal.insert_dev(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			internal.insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const clearnodeprop_changes = {};
			if (dirty & /*nodeData*/ 1) clearnodeprop_changes.onClick = func;
			clearnodeprop.$set(clearnodeprop_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				internal.group_outros();

				internal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				internal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				internal.transition_in(if_block, 1);
				if_block.m(t1.parentNode, t1);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(clearnodeprop.$$.fragment, local);
			internal.transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(clearnodeprop.$$.fragment, local);
			internal.transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			internal.destroy_component(clearnodeprop, detaching);
			if (detaching) internal.detach_dev(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) internal.detach_dev(t1);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(60:12) <Argument {argLevel}                  on:innerDrop={(event) => flowDropHandler({ contextName: 'argument', contextType: argument.returns, stateChangeCallback: addArgument(i) })(event.detail)}                 onClear={() => onClear(i, argument)}                 returnType={argument.returns}>",
		ctx
	});

	return block;
}

// (59:8) {#each nodeData.arguments as argument, i (i)}
function create_each_block$3(key_1, ctx) {
	let first;
	let argument;
	let current;

	function func_1() {
		return /*func_1*/ ctx[13](/*i*/ ctx[17], /*argument*/ ctx[15]);
	}

	function innerDrop_handler(...args) {
		return /*innerDrop_handler*/ ctx[14](/*argument*/ ctx[15], /*i*/ ctx[17], ...args);
	}

	argument = new Argument({
			props: {
				argLevel: /*argLevel*/ ctx[1],
				onClear: func_1,
				returnType: /*argument*/ ctx[15].returns,
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	argument.$on("innerDrop", innerDrop_handler);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = internal.empty();
			internal.create_component(argument.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, first, anchor);
			internal.mount_component(argument, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const argument_changes = {};
			if (dirty & /*argLevel*/ 2) argument_changes.argLevel = /*argLevel*/ ctx[1];
			if (dirty & /*nodeData*/ 1) argument_changes.onClear = func_1;
			if (dirty & /*nodeData*/ 1) argument_changes.returnType = /*argument*/ ctx[15].returns;

			if (dirty & /*$$scope, argLevel, nodeData, nodePath*/ 2097159) {
				argument_changes.$$scope = { dirty, ctx };
			}

			argument.$set(argument_changes);
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(argument.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(argument.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(first);
			internal.destroy_component(argument, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(59:8) {#each nodeData.arguments as argument, i (i)}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div2;
	let p;
	let strong;
	let t0_value = /*nodeData*/ ctx[0].utilityName + "";
	let t0;
	let t1;
	let div0;
	let select;
	let t2;
	let span;
	let t3;
	let t4_value = /*nodeData*/ ctx[0].returns + "";
	let t4;
	let t5;
	let div1;
	let each_blocks = [];
	let each1_lookup = new Map();
	let current;
	let mounted;
	let dispose;
	let each_value_1 = Object.keys(/*utilities*/ ctx[3]).filter(/*matchParentTypeFilter*/ ctx[5]);
	internal.validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*nodeData*/ ctx[0].arguments;
	internal.validate_each_argument(each_value);
	const get_key = ctx => /*i*/ ctx[17];
	internal.validate_each_keys(ctx, each_value, get_each_context$3, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	const block = {
		c: function create() {
			div2 = internal.element("div");
			p = internal.element("p");
			strong = internal.element("strong");
			t0 = internal.text(t0_value);
			t1 = internal.space();
			div0 = internal.element("div");
			select = internal.element("select");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t2 = internal.space();
			span = internal.element("span");
			t3 = internal.text("=> ");
			t4 = internal.text(t4_value);
			t5 = internal.space();
			div1 = internal.element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			internal.add_location(strong, file$8, 48, 7, 1545);
			internal.add_location(p, file$8, 48, 4, 1542);
			internal.add_location(select, file$8, 50, 8, 1632);
			internal.attr_dev(span, "class", "small-text");
			internal.add_location(span, file$8, 55, 8, 1901);
			internal.attr_dev(div0, "class", "method-container");
			internal.add_location(div0, file$8, 49, 4, 1593);
			internal.attr_dev(div1, "class", "arguments-wrapper");
			internal.add_location(div1, file$8, 57, 4, 1973);
			internal.attr_dev(div2, "class", "component-wrapper");
			internal.add_location(div2, file$8, 47, 0, 1506);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div2, anchor);
			internal.append_dev(div2, p);
			internal.append_dev(p, strong);
			internal.append_dev(strong, t0);
			internal.append_dev(div2, t1);
			internal.append_dev(div2, div0);
			internal.append_dev(div0, select);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(select, null);
			}

			internal.append_dev(div0, t2);
			internal.append_dev(div0, span);
			internal.append_dev(span, t3);
			internal.append_dev(span, t4);
			internal.append_dev(div2, t5);
			internal.append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = internal.listen_dev(select, "change", /*onPropertyChange*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*nodeData*/ 1) && t0_value !== (t0_value = /*nodeData*/ ctx[0].utilityName + "")) internal.set_data_dev(t0, t0_value);

			if (dirty & /*Object, utilities, matchParentTypeFilter, nodeData*/ 41) {
				each_value_1 = Object.keys(/*utilities*/ ctx[3]).filter(/*matchParentTypeFilter*/ ctx[5]);
				internal.validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(select, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if ((!current || dirty & /*nodeData*/ 1) && t4_value !== (t4_value = /*nodeData*/ ctx[0].returns + "")) internal.set_data_dev(t4, t4_value);

			if (dirty & /*argLevel, onClear, nodeData, flowDropHandler, addArgument, nodePath, constructors, nodeTemplates*/ 199) {
				each_value = /*nodeData*/ ctx[0].arguments;
				internal.validate_each_argument(each_value);
				internal.group_outros();
				internal.validate_each_keys(ctx, each_value, get_each_context$3, get_key);
				each_blocks = internal.update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, div1, internal.outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
				internal.check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				internal.transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				internal.transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div2);
			internal.destroy_each(each_blocks_1, detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('UtilityCallExpression', slots, []);
	let { nodeData } = $$props;
	let { contextType } = $$props;
	let { isArgument = false } = $$props;
	let { argLevel = 1 } = $$props;
	let { nodePath } = $$props;
	const utilities = typeDefs[nodeData.utilityName];

	function onPropertyChange(event) {
		const utilityMethod = event.target.value;
		const typeDef = typeDefs[nodeData.utilityName][utilityMethod];
		const args = typeDef.args.map(argType => nodeTemplates[argType + "Literal"]({}));

		$$invalidate(0, nodeData = {
			...nodeData,
			utilityMethod,
			arguments: args,
			returns: typeDef.returns
		});
	}

	// !contextType is when things don't have a type in their parent context
	const matchParentTypeFilter = methodName => !contextType || utilities[methodName].returns === contextType;

	const addArgument = argIndex => node => {
		if (node === null) return;
		nodeData.arguments.splice(argIndex, 1, node);
		$$invalidate(0, nodeData.aruments = [...nodeData.arguments], nodeData);
	};

	function onClear(i, argument) {
		$$invalidate(0, nodeData.arguments[i] = nodeTemplates[argument.returns + "Literal"]({}), nodeData);
	}

	const writable_props = ['nodeData', 'contextType', 'isArgument', 'argLevel', 'nodePath'];

	Object_1$2.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UtilityCallExpression> was created with unknown prop '${key}'`);
	});

	const func = (i, argument, _) => $$invalidate(0, nodeData.arguments[i] = nodeTemplates[argument.returns + "Literal"]({}), nodeData);

	function utilitycallexpression_nodeData_binding(value, argument, each_value, i) {
		each_value[i] = value;
		$$invalidate(0, nodeData);
	}

	function switch_instance_nodeData_binding(value, argument, each_value, i) {
		each_value[i] = value;
		$$invalidate(0, nodeData);
	}

	const func_1 = (i, argument) => onClear(i, argument);

	const innerDrop_handler = (argument, i, event) => flowDropHandler({
		contextName: 'argument',
		contextType: argument.returns,
		stateChangeCallback: addArgument(i)
	})(event.detail);

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('contextType' in $$props) $$invalidate(8, contextType = $$props.contextType);
		if ('isArgument' in $$props) $$invalidate(9, isArgument = $$props.isArgument);
		if ('argLevel' in $$props) $$invalidate(1, argLevel = $$props.argLevel);
		if ('nodePath' in $$props) $$invalidate(2, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({
		flowDropHandler,
		typeDefs,
		ClearNodeProp,
		Argument,
		constructors,
		nodeTemplates,
		nodeData,
		contextType,
		isArgument,
		argLevel,
		nodePath,
		utilities,
		onPropertyChange,
		matchParentTypeFilter,
		addArgument,
		onClear
	});

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('contextType' in $$props) $$invalidate(8, contextType = $$props.contextType);
		if ('isArgument' in $$props) $$invalidate(9, isArgument = $$props.isArgument);
		if ('argLevel' in $$props) $$invalidate(1, argLevel = $$props.argLevel);
		if ('nodePath' in $$props) $$invalidate(2, nodePath = $$props.nodePath);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		nodeData,
		argLevel,
		nodePath,
		utilities,
		onPropertyChange,
		matchParentTypeFilter,
		addArgument,
		onClear,
		contextType,
		isArgument,
		func,
		utilitycallexpression_nodeData_binding,
		switch_instance_nodeData_binding,
		func_1,
		innerDrop_handler
	];
}

class UtilityCallExpression extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);

		internal.init(this, options, instance$8, create_fragment$8, internal.safe_not_equal, {
			nodeData: 0,
			contextType: 8,
			isArgument: 9,
			argLevel: 1,
			nodePath: 2
		});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UtilityCallExpression",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<UtilityCallExpression> was created without expected prop 'nodeData'");
		}

		if (/*contextType*/ ctx[8] === undefined && !('contextType' in props)) {
			console.warn("<UtilityCallExpression> was created without expected prop 'contextType'");
		}

		if (/*nodePath*/ ctx[2] === undefined && !('nodePath' in props)) {
			console.warn("<UtilityCallExpression> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<UtilityCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<UtilityCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contextType() {
		throw new Error("<UtilityCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contextType(value) {
		throw new Error("<UtilityCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isArgument() {
		throw new Error("<UtilityCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isArgument(value) {
		throw new Error("<UtilityCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get argLevel() {
		throw new Error("<UtilityCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set argLevel(value) {
		throw new Error("<UtilityCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<UtilityCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<UtilityCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/VarIdentifier.svelte generated by Svelte v3.46.4 */

const { Object: Object_1$1 } = internal.globals;
const file$7 = "src/components/flow_objects/VarIdentifier.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (35:0) {#if nodeData.refId}
function create_if_block_1$1(ctx) {
	let span;
	let t_value = /*$ast*/ ctx[2].main.info.variables[/*nodeData*/ ctx[0].refId].name + "";
	let t;

	const block = {
		c: function create() {
			span = internal.element("span");
			t = internal.text(t_value);
			internal.attr_dev(span, "class", "self svelte-ipghco");
			internal.add_location(span, file$7, 35, 4, 977);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, span, anchor);
			internal.append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$ast, nodeData*/ 5 && t_value !== (t_value = /*$ast*/ ctx[2].main.info.variables[/*nodeData*/ ctx[0].refId].name + "")) internal.set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(span);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(35:0) {#if nodeData.refId}",
		ctx
	});

	return block;
}

// (38:0) {#if availableMethods.length > 0}
function create_if_block$2(ctx) {
	let select;
	let option;
	let select_class_value;
	let mounted;
	let dispose;
	let each_value = Object.keys(/*typeMethods*/ ctx[3]).filter(/*typeMatches*/ ctx[4]);
	internal.validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			select = internal.element("select");
			option = internal.element("option");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			option.selected = true;
			option.__value = "";
			option.value = option.__value;
			internal.add_location(option, file$7, 39, 8, 1192);
			internal.attr_dev(select, "class", select_class_value = "" + (internal.null_to_empty(/*usesTypeMethod*/ ctx[1] ? '' : 'type-method-select') + " svelte-ipghco"));
			internal.add_location(select, file$7, 38, 4, 1095);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, select, anchor);
			internal.append_dev(select, option);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			if (!mounted) {
				dispose = internal.listen_dev(select, "change", /*methodSelected*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*Object, typeMethods, typeMatches*/ 24) {
				each_value = Object.keys(/*typeMethods*/ ctx[3]).filter(/*typeMatches*/ ctx[4]);
				internal.validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*usesTypeMethod*/ 2 && select_class_value !== (select_class_value = "" + (internal.null_to_empty(/*usesTypeMethod*/ ctx[1] ? '' : 'type-method-select') + " svelte-ipghco"))) {
				internal.attr_dev(select, "class", select_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(select);
			internal.destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(38:0) {#if availableMethods.length > 0}",
		ctx
	});

	return block;
}

// (41:8) {#each Object.keys(typeMethods).filter(typeMatches) as typeMethod}
function create_each_block$2(ctx) {
	let option;
	let t_value = /*typeMethod*/ ctx[10] + "";
	let t;

	const block = {
		c: function create() {
			option = internal.element("option");
			t = internal.text(t_value);
			option.__value = /*typeMethod*/ ctx[10];
			option.value = option.__value;
			internal.add_location(option, file$7, 41, 12, 1306);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, option, anchor);
			internal.append_dev(option, t);
		},
		p: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(option);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(41:8) {#each Object.keys(typeMethods).filter(typeMatches) as typeMethod}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let t;
	let if_block1_anchor;
	let if_block0 = /*nodeData*/ ctx[0].refId && create_if_block_1$1(ctx);
	let if_block1 = /*availableMethods*/ ctx[5].length > 0 && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = internal.space();
			if (if_block1) if_block1.c();
			if_block1_anchor = internal.empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			internal.insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			internal.insert_dev(target, if_block1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*nodeData*/ ctx[0].refId) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*availableMethods*/ ctx[5].length > 0) if_block1.p(ctx, dirty);
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) internal.detach_dev(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) internal.detach_dev(if_block1_anchor);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $ast;
	internal.validate_store(ast, 'ast');
	internal.component_subscribe($$self, ast, $$value => $$invalidate(2, $ast = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('VarIdentifier', slots, []);
	let { nodeData } = $$props;
	let { contextType = null } = $$props;
	let { isArgument = false } = $$props;
	let { nodePath } = $$props;
	let usesTypeMethod = false;
	const typeMethods = typeDefs[contextType ?? nodeData.returns];
	const typeMatches = utilityKey => typeMethods[utilityKey].returns === nodeData.returns;

	const availableMethods = contextType ?? false
	? Object.keys(typeMethods).filter(typeMatches)
	: [];

	function methodSelected(event) {
		if (!event.target.value) {
			$$invalidate(1, usesTypeMethod = false);
			return;
		}

		$$invalidate(0, nodeData = nodeTemplates.varCallExpression({
			method: event.target.value,
			returns: nodeData.returns,
			variable: nodeData
		}));

		$$invalidate(1, usesTypeMethod = true);
	}

	const writable_props = ['nodeData', 'contextType', 'isArgument', 'nodePath'];

	Object_1$1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VarIdentifier> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('contextType' in $$props) $$invalidate(7, contextType = $$props.contextType);
		if ('isArgument' in $$props) $$invalidate(8, isArgument = $$props.isArgument);
		if ('nodePath' in $$props) $$invalidate(9, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({
		typeDefs,
		nodeTemplates,
		ast,
		nodeData,
		contextType,
		isArgument,
		nodePath,
		usesTypeMethod,
		typeMethods,
		typeMatches,
		availableMethods,
		methodSelected,
		$ast
	});

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('contextType' in $$props) $$invalidate(7, contextType = $$props.contextType);
		if ('isArgument' in $$props) $$invalidate(8, isArgument = $$props.isArgument);
		if ('nodePath' in $$props) $$invalidate(9, nodePath = $$props.nodePath);
		if ('usesTypeMethod' in $$props) $$invalidate(1, usesTypeMethod = $$props.usesTypeMethod);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		nodeData,
		usesTypeMethod,
		$ast,
		typeMethods,
		typeMatches,
		availableMethods,
		methodSelected,
		contextType,
		isArgument,
		nodePath
	];
}

class VarIdentifier extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);

		internal.init(this, options, instance$7, create_fragment$7, internal.safe_not_equal, {
			nodeData: 0,
			contextType: 7,
			isArgument: 8,
			nodePath: 9
		});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VarIdentifier",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<VarIdentifier> was created without expected prop 'nodeData'");
		}

		if (/*nodePath*/ ctx[9] === undefined && !('nodePath' in props)) {
			console.warn("<VarIdentifier> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<VarIdentifier>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<VarIdentifier>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contextType() {
		throw new Error("<VarIdentifier>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contextType(value) {
		throw new Error("<VarIdentifier>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isArgument() {
		throw new Error("<VarIdentifier>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isArgument(value) {
		throw new Error("<VarIdentifier>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<VarIdentifier>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<VarIdentifier>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/VarCallExpression.svelte generated by Svelte v3.46.4 */

const { Object: Object_1 } = internal.globals;
const file$6 = "src/components/flow_objects/VarCallExpression.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[17] = list;
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	return child_ctx;
}

// (61:12) {#if !contextType || nodeData.variable.returns === contextType}
function create_if_block_1(ctx) {
	let option;

	const block = {
		c: function create() {
			option = internal.element("option");
			option.__value = "";
			option.value = option.__value;
			internal.add_location(option, file$6, 60, 75, 1977);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, option, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(option);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(61:12) {#if !contextType || nodeData.variable.returns === contextType}",
		ctx
	});

	return block;
}

// (62:12) {#each Object.keys(varTypeMethods).filter(matchParentTypeFilter) as method}
function create_each_block_1(ctx) {
	let option;
	let t_value = /*method*/ ctx[19] + "";
	let t;
	let option_selected_value;

	const block = {
		c: function create() {
			option = internal.element("option");
			t = internal.text(t_value);
			option.__value = /*method*/ ctx[19];
			option.value = option.__value;
			option.selected = option_selected_value = /*method*/ ctx[19] === /*nodeData*/ ctx[0].method;
			internal.add_location(option, file$6, 62, 16, 2113);
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, option, anchor);
			internal.append_dev(option, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*nodeData*/ 1 && option_selected_value !== (option_selected_value = /*method*/ ctx[19] === /*nodeData*/ ctx[0].method)) {
				internal.prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(option);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(62:12) {#each Object.keys(varTypeMethods).filter(matchParentTypeFilter) as method}",
		ctx
	});

	return block;
}

// (78:16) {:else}
function create_else_block$1(ctx) {
	let switch_instance;
	let updating_nodeData;
	let switch_instance_anchor;
	let current;

	function switch_instance_nodeData_binding(value) {
		/*switch_instance_nodeData_binding*/ ctx[13](value, /*argument*/ ctx[16], /*each_value*/ ctx[17], /*i*/ ctx[18]);
	}

	var switch_value = constructors[/*argument*/ ctx[16].type];

	function switch_props(ctx) {
		let switch_instance_props = {
			argLevel: /*argLevel*/ ctx[2] + 1,
			isArgument: true,
			contextType: /*argument*/ ctx[16].returns,
			nodePath: /*nodePath*/ ctx[3] + ".arguments." + /*i*/ ctx[18]
		};

		if (/*argument*/ ctx[16] !== void 0) {
			switch_instance_props.nodeData = /*argument*/ ctx[16];
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
	}

	const block = {
		c: function create() {
			if (switch_instance) internal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = internal.empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				internal.mount_component(switch_instance, target, anchor);
			}

			internal.insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const switch_instance_changes = {};
			if (dirty & /*argLevel*/ 4) switch_instance_changes.argLevel = /*argLevel*/ ctx[2] + 1;
			if (dirty & /*nodeData*/ 1) switch_instance_changes.contextType = /*argument*/ ctx[16].returns;
			if (dirty & /*nodePath, nodeData*/ 9) switch_instance_changes.nodePath = /*nodePath*/ ctx[3] + ".arguments." + /*i*/ ctx[18];

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				switch_instance_changes.nodeData = /*argument*/ ctx[16];
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			if (switch_value !== (switch_value = constructors[/*argument*/ ctx[16].type])) {
				if (switch_instance) {
					internal.group_outros();
					const old_component = switch_instance;

					internal.transition_out(old_component.$$.fragment, 1, 0, () => {
						internal.destroy_component(old_component, 1);
					});

					internal.check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
					internal.create_component(switch_instance.$$.fragment);
					internal.transition_in(switch_instance.$$.fragment, 1);
					internal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) internal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) internal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(switch_instance_anchor);
			if (switch_instance) internal.destroy_component(switch_instance, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(78:16) {:else}",
		ctx
	});

	return block;
}

// (76:16) {#if argument.type === "VarCallExpression"}
function create_if_block$1(ctx) {
	let varcallexpression;
	let updating_nodeData;
	let current;

	function varcallexpression_nodeData_binding(value) {
		/*varcallexpression_nodeData_binding*/ ctx[12](value, /*argument*/ ctx[16], /*each_value*/ ctx[17], /*i*/ ctx[18]);
	}

	let varcallexpression_props = {
		argLevel: /*argLevel*/ ctx[2] + 1,
		isArgument: true,
		contextType: /*argument*/ ctx[16].returns,
		nodePath: /*nodePath*/ ctx[3] + ".arguments." + /*i*/ ctx[18]
	};

	if (/*argument*/ ctx[16] !== void 0) {
		varcallexpression_props.nodeData = /*argument*/ ctx[16];
	}

	varcallexpression = new VarCallExpression({
			props: varcallexpression_props,
			$$inline: true
		});

	internal.binding_callbacks.push(() => internal.bind(varcallexpression, 'nodeData', varcallexpression_nodeData_binding));

	const block = {
		c: function create() {
			internal.create_component(varcallexpression.$$.fragment);
		},
		m: function mount(target, anchor) {
			internal.mount_component(varcallexpression, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const varcallexpression_changes = {};
			if (dirty & /*argLevel*/ 4) varcallexpression_changes.argLevel = /*argLevel*/ ctx[2] + 1;
			if (dirty & /*nodeData*/ 1) varcallexpression_changes.contextType = /*argument*/ ctx[16].returns;
			if (dirty & /*nodePath, nodeData*/ 9) varcallexpression_changes.nodePath = /*nodePath*/ ctx[3] + ".arguments." + /*i*/ ctx[18];

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				varcallexpression_changes.nodeData = /*argument*/ ctx[16];
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			varcallexpression.$set(varcallexpression_changes);
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(varcallexpression.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(varcallexpression.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			internal.destroy_component(varcallexpression, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(76:16) {#if argument.type === \\\"VarCallExpression\\\"}",
		ctx
	});

	return block;
}

// (70:12) <Argument {argLevel}                  on:innerDrop={(event) => flowDropHandler({ contextName: 'argument', contextType: argument.returns, stateChangeCallback: dropArgument(i) })(event.detail)}                 onClear={() => onClear(i, argument)}                 returnType={argument.returns}>
function create_default_slot(ctx) {
	let clearnodeprop;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;

	function func(...args) {
		return /*func*/ ctx[11](/*i*/ ctx[18], /*argument*/ ctx[16], ...args);
	}

	clearnodeprop = new ClearNodeProp({ props: { onClick: func }, $$inline: true });
	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*argument*/ ctx[16].type === "VarCallExpression") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			internal.create_component(clearnodeprop.$$.fragment);
			t0 = internal.space();
			if_block.c();
			t1 = internal.space();
		},
		m: function mount(target, anchor) {
			internal.mount_component(clearnodeprop, target, anchor);
			internal.insert_dev(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			internal.insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const clearnodeprop_changes = {};
			if (dirty & /*nodeData*/ 1) clearnodeprop_changes.onClick = func;
			clearnodeprop.$set(clearnodeprop_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				internal.group_outros();

				internal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				internal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				internal.transition_in(if_block, 1);
				if_block.m(t1.parentNode, t1);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(clearnodeprop.$$.fragment, local);
			internal.transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(clearnodeprop.$$.fragment, local);
			internal.transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			internal.destroy_component(clearnodeprop, detaching);
			if (detaching) internal.detach_dev(t0);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) internal.detach_dev(t1);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(70:12) <Argument {argLevel}                  on:innerDrop={(event) => flowDropHandler({ contextName: 'argument', contextType: argument.returns, stateChangeCallback: dropArgument(i) })(event.detail)}                 onClear={() => onClear(i, argument)}                 returnType={argument.returns}>",
		ctx
	});

	return block;
}

// (69:8) {#each nodeData.arguments as argument, i (i)}
function create_each_block$1(key_1, ctx) {
	let first;
	let argument;
	let current;

	function func_1() {
		return /*func_1*/ ctx[14](/*i*/ ctx[18], /*argument*/ ctx[16]);
	}

	function innerDrop_handler(...args) {
		return /*innerDrop_handler*/ ctx[15](/*argument*/ ctx[16], /*i*/ ctx[18], ...args);
	}

	argument = new Argument({
			props: {
				argLevel: /*argLevel*/ ctx[2],
				onClear: func_1,
				returnType: /*argument*/ ctx[16].returns,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	argument.$on("innerDrop", innerDrop_handler);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = internal.empty();
			internal.create_component(argument.$$.fragment);
			this.first = first;
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, first, anchor);
			internal.mount_component(argument, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const argument_changes = {};
			if (dirty & /*argLevel*/ 4) argument_changes.argLevel = /*argLevel*/ ctx[2];
			if (dirty & /*nodeData*/ 1) argument_changes.onClear = func_1;
			if (dirty & /*nodeData*/ 1) argument_changes.returnType = /*argument*/ ctx[16].returns;

			if (dirty & /*$$scope, argLevel, nodeData, nodePath*/ 4194317) {
				argument_changes.$$scope = { dirty, ctx };
			}

			argument.$set(argument_changes);
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(argument.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(argument.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(first);
			internal.destroy_component(argument, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(69:8) {#each nodeData.arguments as argument, i (i)}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div2;
	let p;
	let strong;
	let varidentifier;
	let updating_nodeData;
	let t0;
	let div0;
	let select;
	let if_block_anchor;
	let t1;
	let span;
	let t2;
	let t3_value = /*nodeData*/ ctx[0].returns + "";
	let t3;
	let t4;
	let div1;
	let each_blocks = [];
	let each1_lookup = new Map();
	let current;
	let mounted;
	let dispose;

	function varidentifier_nodeData_binding(value) {
		/*varidentifier_nodeData_binding*/ ctx[10](value);
	}

	let varidentifier_props = { isArgument: false };

	if (/*nodeData*/ ctx[0].variable !== void 0) {
		varidentifier_props.nodeData = /*nodeData*/ ctx[0].variable;
	}

	varidentifier = new VarIdentifier({
			props: varidentifier_props,
			$$inline: true
		});

	internal.binding_callbacks.push(() => internal.bind(varidentifier, 'nodeData', varidentifier_nodeData_binding));
	let if_block = (!/*contextType*/ ctx[1] || /*nodeData*/ ctx[0].variable.returns === /*contextType*/ ctx[1]) && create_if_block_1(ctx);
	let each_value_1 = Object.keys(/*varTypeMethods*/ ctx[4]).filter(/*matchParentTypeFilter*/ ctx[6]);
	internal.validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*nodeData*/ ctx[0].arguments;
	internal.validate_each_argument(each_value);
	const get_key = ctx => /*i*/ ctx[18];
	internal.validate_each_keys(ctx, each_value, get_each_context$1, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			div2 = internal.element("div");
			p = internal.element("p");
			strong = internal.element("strong");
			internal.create_component(varidentifier.$$.fragment);
			t0 = internal.space();
			div0 = internal.element("div");
			select = internal.element("select");
			if (if_block) if_block.c();
			if_block_anchor = internal.empty();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = internal.space();
			span = internal.element("span");
			t2 = internal.text("=> ");
			t3 = internal.text(t3_value);
			t4 = internal.space();
			div1 = internal.element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			internal.add_location(strong, file$6, 57, 7, 1729);
			internal.add_location(p, file$6, 57, 4, 1726);
			internal.add_location(select, file$6, 59, 8, 1864);
			internal.attr_dev(span, "class", "small-text");
			internal.add_location(span, file$6, 65, 8, 2238);
			internal.attr_dev(div0, "class", "method-container");
			internal.add_location(div0, file$6, 58, 4, 1825);
			internal.attr_dev(div1, "class", "arguments-wrapper");
			internal.add_location(div1, file$6, 67, 4, 2310);
			internal.attr_dev(div2, "class", "component-wrapper");
			internal.add_location(div2, file$6, 56, 0, 1690);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div2, anchor);
			internal.append_dev(div2, p);
			internal.append_dev(p, strong);
			internal.mount_component(varidentifier, strong, null);
			internal.append_dev(div2, t0);
			internal.append_dev(div2, div0);
			internal.append_dev(div0, select);
			if (if_block) if_block.m(select, null);
			internal.append_dev(select, if_block_anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(select, null);
			}

			internal.append_dev(div0, t1);
			internal.append_dev(div0, span);
			internal.append_dev(span, t2);
			internal.append_dev(span, t3);
			internal.append_dev(div2, t4);
			internal.append_dev(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = internal.listen_dev(select, "change", /*onPropertyChange*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const varidentifier_changes = {};

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				varidentifier_changes.nodeData = /*nodeData*/ ctx[0].variable;
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			varidentifier.$set(varidentifier_changes);

			if (!/*contextType*/ ctx[1] || /*nodeData*/ ctx[0].variable.returns === /*contextType*/ ctx[1]) {
				if (if_block) ; else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(select, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*Object, varTypeMethods, matchParentTypeFilter, nodeData*/ 81) {
				each_value_1 = Object.keys(/*varTypeMethods*/ ctx[4]).filter(/*matchParentTypeFilter*/ ctx[6]);
				internal.validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(select, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if ((!current || dirty & /*nodeData*/ 1) && t3_value !== (t3_value = /*nodeData*/ ctx[0].returns + "")) internal.set_data_dev(t3, t3_value);

			if (dirty & /*argLevel, onClear, nodeData, flowDropHandler, dropArgument, nodePath, constructors, nodeTemplates*/ 397) {
				each_value = /*nodeData*/ ctx[0].arguments;
				internal.validate_each_argument(each_value);
				internal.group_outros();
				internal.validate_each_keys(ctx, each_value, get_each_context$1, get_key);
				each_blocks = internal.update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, div1, internal.outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
				internal.check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(varidentifier.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				internal.transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			internal.transition_out(varidentifier.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				internal.transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div2);
			internal.destroy_component(varidentifier);
			if (if_block) if_block.d();
			internal.destroy_each(each_blocks_1, detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('VarCallExpression', slots, []);
	let { nodeData } = $$props;
	let { contextType } = $$props;
	let { isArgument = false } = $$props;
	let { argLevel = 1 } = $$props;
	let { nodePath } = $$props;
	let varTypeMethods = typeDefs[nodeData.variable.returns];

	function onPropertyChange(event) {
		const method = event.target.value;

		if (method === '') {
			$$invalidate(0, nodeData = { ...nodeData.variable });
			return;
		}

		const typeDef = varTypeMethods[method];
		const args = typeDef.args.map(argType => nodeTemplates[argType + "Literal"]({}));

		$$invalidate(0, nodeData = {
			...nodeData,
			method,
			arguments: args,
			returns: typeDef.returns
		});
	}

	// !contextType is when things don't have a type in their parent context
	const matchParentTypeFilter = methodName => !contextType || varTypeMethods[methodName].returns === contextType;

	const dropArgument = argIndex => node => {
		if (node === null) return;
		nodeData.arguments.splice(argIndex, 1, node);
		$$invalidate(0, nodeData.aruments = [...nodeData.arguments], nodeData);
	};

	function onClear(i, argument) {
		$$invalidate(0, nodeData.arguments[i] = nodeTemplates[argument.returns + "Literal"]({}), nodeData);
	}

	const writable_props = ['nodeData', 'contextType', 'isArgument', 'argLevel', 'nodePath'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VarCallExpression> was created with unknown prop '${key}'`);
	});

	function varidentifier_nodeData_binding(value) {
		if ($$self.$$.not_equal(nodeData.variable, value)) {
			nodeData.variable = value;
			$$invalidate(0, nodeData);
		}
	}

	const func = (i, argument, _) => $$invalidate(0, nodeData.arguments[i] = nodeTemplates[argument.returns + "Literal"]({}), nodeData);

	function varcallexpression_nodeData_binding(value, argument, each_value, i) {
		each_value[i] = value;
		$$invalidate(0, nodeData);
	}

	function switch_instance_nodeData_binding(value, argument, each_value, i) {
		each_value[i] = value;
		$$invalidate(0, nodeData);
	}

	const func_1 = (i, argument) => onClear(i, argument);

	const innerDrop_handler = (argument, i, event) => flowDropHandler({
		contextName: 'argument',
		contextType: argument.returns,
		stateChangeCallback: dropArgument(i)
	})(event.detail);

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('contextType' in $$props) $$invalidate(1, contextType = $$props.contextType);
		if ('isArgument' in $$props) $$invalidate(9, isArgument = $$props.isArgument);
		if ('argLevel' in $$props) $$invalidate(2, argLevel = $$props.argLevel);
		if ('nodePath' in $$props) $$invalidate(3, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({
		VarIdentifier,
		Argument,
		flowDropHandler,
		typeDefs,
		ClearNodeProp,
		constructors,
		nodeTemplates,
		nodeData,
		contextType,
		isArgument,
		argLevel,
		nodePath,
		varTypeMethods,
		onPropertyChange,
		matchParentTypeFilter,
		dropArgument,
		onClear
	});

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('contextType' in $$props) $$invalidate(1, contextType = $$props.contextType);
		if ('isArgument' in $$props) $$invalidate(9, isArgument = $$props.isArgument);
		if ('argLevel' in $$props) $$invalidate(2, argLevel = $$props.argLevel);
		if ('nodePath' in $$props) $$invalidate(3, nodePath = $$props.nodePath);
		if ('varTypeMethods' in $$props) $$invalidate(4, varTypeMethods = $$props.varTypeMethods);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		nodeData,
		contextType,
		argLevel,
		nodePath,
		varTypeMethods,
		onPropertyChange,
		matchParentTypeFilter,
		dropArgument,
		onClear,
		isArgument,
		varidentifier_nodeData_binding,
		func,
		varcallexpression_nodeData_binding,
		switch_instance_nodeData_binding,
		func_1,
		innerDrop_handler
	];
}

class VarCallExpression extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);

		internal.init(this, options, instance$6, create_fragment$6, internal.safe_not_equal, {
			nodeData: 0,
			contextType: 1,
			isArgument: 9,
			argLevel: 2,
			nodePath: 3
		});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VarCallExpression",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<VarCallExpression> was created without expected prop 'nodeData'");
		}

		if (/*contextType*/ ctx[1] === undefined && !('contextType' in props)) {
			console.warn("<VarCallExpression> was created without expected prop 'contextType'");
		}

		if (/*nodePath*/ ctx[3] === undefined && !('nodePath' in props)) {
			console.warn("<VarCallExpression> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<VarCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<VarCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contextType() {
		throw new Error("<VarCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contextType(value) {
		throw new Error("<VarCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isArgument() {
		throw new Error("<VarCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isArgument(value) {
		throw new Error("<VarCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get argLevel() {
		throw new Error("<VarCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set argLevel(value) {
		throw new Error("<VarCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<VarCallExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<VarCallExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/Identifier.svelte generated by Svelte v3.46.4 */

const file$5 = "src/components/flow_objects/Identifier.svelte";

function create_fragment$5(ctx) {
	let span;
	let t_value = /*nodeData*/ ctx[0].name + "";
	let t;

	const block = {
		c: function create() {
			span = internal.element("span");
			t = internal.text(t_value);
			internal.attr_dev(span, "class", "self svelte-195lgj9");
			internal.add_location(span, file$5, 6, 0, 75);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, span, anchor);
			internal.append_dev(span, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*nodeData*/ 1 && t_value !== (t_value = /*nodeData*/ ctx[0].name + "")) internal.set_data_dev(t, t_value);
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(span);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('Identifier', slots, []);
	let { nodeData } = $$props;
	let { nodePath } = $$props;
	const writable_props = ['nodeData', 'nodePath'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Identifier> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(1, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({ nodeData, nodePath });

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(1, nodePath = $$props.nodePath);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [nodeData, nodePath];
}

class Identifier extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$5, create_fragment$5, internal.safe_not_equal, { nodeData: 0, nodePath: 1 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Identifier",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<Identifier> was created without expected prop 'nodeData'");
		}

		if (/*nodePath*/ ctx[1] === undefined && !('nodePath' in props)) {
			console.warn("<Identifier> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<Identifier>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<Identifier>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<Identifier>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<Identifier>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/StringLiteral.svelte generated by Svelte v3.46.4 */

const file$4 = "src/components/flow_objects/StringLiteral.svelte";

function create_fragment$4(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = internal.element("input");
			internal.attr_dev(input, "type", "text");
			input.value = input_value_value = /*nodeData*/ ctx[0].value;
			internal.add_location(input, file$4, 14, 0, 242);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = [
					internal.listen_dev(input, "change", /*updateValue*/ ctx[1], false, false, false),
					internal.listen_dev(input, "dragStart", internal.stop_propagation(dragStart_handler), false, false, true)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*nodeData*/ 1 && input_value_value !== (input_value_value = /*nodeData*/ ctx[0].value) && input.value !== input_value_value) {
				internal.prop_dev(input, "value", input_value_value);
			}
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(input);
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const dragStart_handler = () => {
	
};

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('StringLiteral', slots, []);
	let { nodeData } = $$props;
	let { isArgument = false } = $$props;
	let { nodePath } = $$props;

	function updateValue(event) {
		$$invalidate(0, nodeData = { ...nodeData, value: event.target.value });
	}

	const writable_props = ['nodeData', 'isArgument', 'nodePath'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StringLiteral> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('isArgument' in $$props) $$invalidate(2, isArgument = $$props.isArgument);
		if ('nodePath' in $$props) $$invalidate(3, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({
		nodeData,
		isArgument,
		nodePath,
		updateValue
	});

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('isArgument' in $$props) $$invalidate(2, isArgument = $$props.isArgument);
		if ('nodePath' in $$props) $$invalidate(3, nodePath = $$props.nodePath);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [nodeData, updateValue, isArgument, nodePath];
}

class StringLiteral extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$4, create_fragment$4, internal.safe_not_equal, { nodeData: 0, isArgument: 2, nodePath: 3 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StringLiteral",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<StringLiteral> was created without expected prop 'nodeData'");
		}

		if (/*nodePath*/ ctx[3] === undefined && !('nodePath' in props)) {
			console.warn("<StringLiteral> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<StringLiteral>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<StringLiteral>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isArgument() {
		throw new Error("<StringLiteral>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isArgument(value) {
		throw new Error("<StringLiteral>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<StringLiteral>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<StringLiteral>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/IntegerLiteral.svelte generated by Svelte v3.46.4 */

const file$3 = "src/components/flow_objects/IntegerLiteral.svelte";

function create_fragment$3(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = internal.element("input");
			internal.attr_dev(input, "type", "number");
			input.value = input_value_value = /*nodeData*/ ctx[0].value;
			internal.add_location(input, file$3, 15, 0, 258);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, input, anchor);

			if (!mounted) {
				dispose = internal.listen_dev(input, "change", /*updateValue*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*nodeData*/ 1 && input_value_value !== (input_value_value = /*nodeData*/ ctx[0].value) && input.value !== input_value_value) {
				internal.prop_dev(input, "value", input_value_value);
			}
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('IntegerLiteral', slots, []);
	let { nodeData } = $$props;
	let { nodePath } = $$props;

	/**
 * @param {Event} event
 */
	function updateValue(event) {
		$$invalidate(0, nodeData = {
			...nodeData,
			value: event.target.valueAsNumber
		});
	}

	const writable_props = ['nodeData', 'nodePath'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IntegerLiteral> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(2, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({ nodeData, nodePath, updateValue });

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(2, nodePath = $$props.nodePath);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [nodeData, updateValue, nodePath];
}

class IntegerLiteral extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$3, create_fragment$3, internal.safe_not_equal, { nodeData: 0, nodePath: 2 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "IntegerLiteral",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<IntegerLiteral> was created without expected prop 'nodeData'");
		}

		if (/*nodePath*/ ctx[2] === undefined && !('nodePath' in props)) {
			console.warn("<IntegerLiteral> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<IntegerLiteral>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<IntegerLiteral>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<IntegerLiteral>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<IntegerLiteral>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/flow_objects/AssignmentExpression.svelte generated by Svelte v3.46.4 */
const file$2 = "src/components/flow_objects/AssignmentExpression.svelte";

// (32:8) {:else}
function create_else_block(ctx) {
	let clearnodeprop;
	let t;
	let switch_instance;
	let updating_nodeData;
	let switch_instance_anchor;
	let current;

	clearnodeprop = new ClearNodeProp({
			props: { onClick: /*func*/ ctx[4] },
			$$inline: true
		});

	function switch_instance_nodeData_binding(value) {
		/*switch_instance_nodeData_binding*/ ctx[5](value);
	}

	var switch_value = constructors[/*nodeData*/ ctx[0].right.type];

	function switch_props(ctx) {
		let switch_instance_props = {
			contextType: /*nodeData*/ ctx[0].left.returns,
			nodePath: /*nodePath*/ ctx[1] + ".right"
		};

		if (/*nodeData*/ ctx[0].right !== void 0) {
			switch_instance_props.nodeData = /*nodeData*/ ctx[0].right;
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
	}

	const block = {
		c: function create() {
			internal.create_component(clearnodeprop.$$.fragment);
			t = internal.space();
			if (switch_instance) internal.create_component(switch_instance.$$.fragment);
			switch_instance_anchor = internal.empty();
		},
		m: function mount(target, anchor) {
			internal.mount_component(clearnodeprop, target, anchor);
			internal.insert_dev(target, t, anchor);

			if (switch_instance) {
				internal.mount_component(switch_instance, target, anchor);
			}

			internal.insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const clearnodeprop_changes = {};
			if (dirty & /*nodeData*/ 1) clearnodeprop_changes.onClick = /*func*/ ctx[4];
			clearnodeprop.$set(clearnodeprop_changes);
			const switch_instance_changes = {};
			if (dirty & /*nodeData*/ 1) switch_instance_changes.contextType = /*nodeData*/ ctx[0].left.returns;
			if (dirty & /*nodePath*/ 2) switch_instance_changes.nodePath = /*nodePath*/ ctx[1] + ".right";

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				switch_instance_changes.nodeData = /*nodeData*/ ctx[0].right;
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			if (switch_value !== (switch_value = constructors[/*nodeData*/ ctx[0].right.type])) {
				if (switch_instance) {
					internal.group_outros();
					const old_component = switch_instance;

					internal.transition_out(old_component.$$.fragment, 1, 0, () => {
						internal.destroy_component(old_component, 1);
					});

					internal.check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
					internal.create_component(switch_instance.$$.fragment);
					internal.transition_in(switch_instance.$$.fragment, 1);
					internal.mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(clearnodeprop.$$.fragment, local);
			if (switch_instance) internal.transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(clearnodeprop.$$.fragment, local);
			if (switch_instance) internal.transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			internal.destroy_component(clearnodeprop, detaching);
			if (detaching) internal.detach_dev(t);
			if (detaching) internal.detach_dev(switch_instance_anchor);
			if (switch_instance) internal.destroy_component(switch_instance, detaching);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(32:8) {:else}",
		ctx
	});

	return block;
}

// (30:8) {#if nodeData.right === null}
function create_if_block(ctx) {
	let t;

	const block = {
		c: function create() {
			t = internal.text("Drag an expression here");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, t, anchor);
		},
		p: internal.noop,
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(t);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(30:8) {#if nodeData.right === null}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div2;
	let div0;
	let p0;
	let t0;
	let t1_value = /*nodeData*/ ctx[0].left.returns + "";
	let t1;
	let t2;
	let t3;
	let p1;
	let strong;
	let varidentifier;
	let updating_nodeData;
	let t4;
	let p2;
	let t6;
	let p3;
	let t8;
	let div1;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;

	function varidentifier_nodeData_binding(value) {
		/*varidentifier_nodeData_binding*/ ctx[3](value);
	}

	let varidentifier_props = {
		isArgument: false,
		nodePath: /*nodePath*/ ctx[1] + ".left"
	};

	if (/*nodeData*/ ctx[0].left !== void 0) {
		varidentifier_props.nodeData = /*nodeData*/ ctx[0].left;
	}

	varidentifier = new VarIdentifier({
			props: varidentifier_props,
			$$inline: true
		});

	internal.binding_callbacks.push(() => internal.bind(varidentifier, 'nodeData', varidentifier_nodeData_binding));
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*nodeData*/ ctx[0].right === null) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div2 = internal.element("div");
			div0 = internal.element("div");
			p0 = internal.element("p");
			t0 = internal.text("Set ");
			t1 = internal.text(t1_value);
			t2 = internal.text(",");
			t3 = internal.space();
			p1 = internal.element("p");
			strong = internal.element("strong");
			internal.create_component(varidentifier.$$.fragment);
			t4 = internal.space();
			p2 = internal.element("p");
			p2.textContent = "to";
			t6 = internal.space();
			p3 = internal.element("p");
			p3.textContent = "=";
			t8 = internal.space();
			div1 = internal.element("div");
			if_block.c();
			internal.add_location(p0, file$2, 18, 8, 494);
			internal.add_location(strong, file$2, 20, 12, 554);
			internal.add_location(p1, file$2, 19, 8, 538);
			internal.add_location(p2, file$2, 22, 8, 689);
			internal.attr_dev(div0, "class", "set-block svelte-1m97shb");
			internal.add_location(div0, file$2, 17, 4, 462);
			internal.attr_dev(p3, "class", "equality-symbol svelte-1m97shb");
			internal.add_location(p3, file$2, 24, 4, 714);
			internal.attr_dev(div1, "class", "assign-right-block flex-1 svelte-1m97shb");
			internal.add_location(div1, file$2, 25, 4, 753);
			internal.attr_dev(div2, "class", "flex");
			internal.add_location(div2, file$2, 16, 0, 439);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div2, anchor);
			internal.append_dev(div2, div0);
			internal.append_dev(div0, p0);
			internal.append_dev(p0, t0);
			internal.append_dev(p0, t1);
			internal.append_dev(p0, t2);
			internal.append_dev(div0, t3);
			internal.append_dev(div0, p1);
			internal.append_dev(p1, strong);
			internal.mount_component(varidentifier, strong, null);
			internal.append_dev(div0, t4);
			internal.append_dev(div0, p2);
			internal.append_dev(div2, t6);
			internal.append_dev(div2, p3);
			internal.append_dev(div2, t8);
			internal.append_dev(div2, div1);
			if_blocks[current_block_type_index].m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					internal.listen_dev(div1, "dragover", dragover_handler, false, false, false),
					internal.listen_dev(
						div1,
						"drop",
						internal.stop_propagation(function () {
							if (internal.is_function(flowDropHandler({
								contextName: 'assignment',
								contextType: /*nodeData*/ ctx[0].left.returns,
								stateChangeCallback: /*stateChangeOnDrop*/ ctx[2]
							}))) flowDropHandler({
								contextName: 'assignment',
								contextType: /*nodeData*/ ctx[0].left.returns,
								stateChangeCallback: /*stateChangeOnDrop*/ ctx[2]
							}).apply(this, arguments);
						}),
						false,
						false,
						true
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			if ((!current || dirty & /*nodeData*/ 1) && t1_value !== (t1_value = /*nodeData*/ ctx[0].left.returns + "")) internal.set_data_dev(t1, t1_value);
			const varidentifier_changes = {};
			if (dirty & /*nodePath*/ 2) varidentifier_changes.nodePath = /*nodePath*/ ctx[1] + ".left";

			if (!updating_nodeData && dirty & /*nodeData*/ 1) {
				updating_nodeData = true;
				varidentifier_changes.nodeData = /*nodeData*/ ctx[0].left;
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			varidentifier.$set(varidentifier_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				internal.group_outros();

				internal.transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				internal.check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				internal.transition_in(if_block, 1);
				if_block.m(div1, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(varidentifier.$$.fragment, local);
			internal.transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			internal.transition_out(varidentifier.$$.fragment, local);
			internal.transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div2);
			internal.destroy_component(varidentifier);
			if_blocks[current_block_type_index].d();
			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const dragover_handler = () => {
	
};

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('AssignmentExpression', slots, []);
	let { nodeData } = $$props;
	let { nodePath } = $$props;

	const stateChangeOnDrop = node => {
		if (node === null) return;
		$$invalidate(0, nodeData.right = node, nodeData);
	};

	const writable_props = ['nodeData', 'nodePath'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AssignmentExpression> was created with unknown prop '${key}'`);
	});

	function varidentifier_nodeData_binding(value) {
		if ($$self.$$.not_equal(nodeData.left, value)) {
			nodeData.left = value;
			$$invalidate(0, nodeData);
		}
	}

	const func = _ => $$invalidate(0, nodeData.right = null, nodeData);

	function switch_instance_nodeData_binding(value) {
		if ($$self.$$.not_equal(nodeData.right, value)) {
			nodeData.right = value;
			$$invalidate(0, nodeData);
		}
	}

	$$self.$$set = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(1, nodePath = $$props.nodePath);
	};

	$$self.$capture_state = () => ({
		constructors,
		VarIdentifier,
		flowDropHandler,
		ClearNodeProp,
		nodeData,
		nodePath,
		stateChangeOnDrop
	});

	$$self.$inject_state = $$props => {
		if ('nodeData' in $$props) $$invalidate(0, nodeData = $$props.nodeData);
		if ('nodePath' in $$props) $$invalidate(1, nodePath = $$props.nodePath);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		nodeData,
		nodePath,
		stateChangeOnDrop,
		varidentifier_nodeData_binding,
		func,
		switch_instance_nodeData_binding
	];
}

class AssignmentExpression extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$2, create_fragment$2, internal.safe_not_equal, { nodeData: 0, nodePath: 1 });

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AssignmentExpression",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*nodeData*/ ctx[0] === undefined && !('nodeData' in props)) {
			console.warn("<AssignmentExpression> was created without expected prop 'nodeData'");
		}

		if (/*nodePath*/ ctx[1] === undefined && !('nodePath' in props)) {
			console.warn("<AssignmentExpression> was created without expected prop 'nodePath'");
		}
	}

	get nodeData() {
		throw new Error("<AssignmentExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeData(value) {
		throw new Error("<AssignmentExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodePath() {
		throw new Error("<AssignmentExpression>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodePath(value) {
		throw new Error("<AssignmentExpression>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// Constructors to use in <svelte:component> tags, keyed by the 'type' from the AST
const constructors = {
    "ExpressionStatement": ExpressionStatement,
    "UtilityCallExpression": UtilityCallExpression,
    "VarCallExpression": VarCallExpression,
    "Identifier": Identifier,
    "StringLiteral": StringLiteral,
    "IntegerLiteral": IntegerLiteral,
    "AssignmentExpression": AssignmentExpression,
    "VarIdentifier": VarIdentifier
};

function squish(node, params) {
    const { opacity = 0, start = 0 } = params;

    return {
        delay: params.delay || 0,
        duration: params.duration || 400,
        easing: params.easing || easing.cubicOut,
        css(t, _) {
            const o = t * (1 - opacity) + opacity;
            const s = t * (1 - start) + start;
            return `
                transform: scaleY(${s});
                opacity: ${o};
            `;
        }
    };
}

/* src/components/container_components/FlowController.svelte generated by Svelte v3.46.4 */
const file$1 = "src/components/container_components/FlowController.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[20] = list;
	child_ctx[21] = i;
	return child_ctx;
}

// (84:8) {#each $ast.main.body as flowObject, i (flowObject.id)}
function create_each_block(key_1, ctx) {
	let div;
	let switch_instance;
	let updating_nodeData;
	let div_transition;
	let rect;
	let stop_animation = internal.noop;
	let current;

	function switch_instance_nodeData_binding(value) {
		/*switch_instance_nodeData_binding*/ ctx[13](value, /*flowObject*/ ctx[19], /*each_value*/ ctx[20], /*i*/ ctx[21]);
	}

	function insertAfter_handler(...args) {
		return /*insertAfter_handler*/ ctx[15](/*i*/ ctx[21], ...args);
	}

	var switch_value = constructors[/*flowObject*/ ctx[19].type];

	function switch_props(ctx) {
		let switch_instance_props = {
			accessor: /*i*/ ctx[21],
			nodePath: `ast.main.body.${/*i*/ ctx[21]}`
		};

		if (/*flowObject*/ ctx[19] !== void 0) {
			switch_instance_props.nodeData = /*flowObject*/ ctx[19];
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
		internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
		switch_instance.$on("delete", /*delete_handler*/ ctx[14]);
		switch_instance.$on("insertAfter", insertAfter_handler);
		switch_instance.$on("moveExpression", /*moveExpression_handler*/ ctx[16]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = internal.element("div");
			if (switch_instance) internal.create_component(switch_instance.$$.fragment);
			internal.add_location(div, file$1, 84, 12, 2640);
			this.first = div;
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div, anchor);

			if (switch_instance) {
				internal.mount_component(switch_instance, div, null);
			}

			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const switch_instance_changes = {};
			if (dirty & /*$ast*/ 4) switch_instance_changes.accessor = /*i*/ ctx[21];
			if (dirty & /*$ast*/ 4) switch_instance_changes.nodePath = `ast.main.body.${/*i*/ ctx[21]}`;

			if (!updating_nodeData && dirty & /*$ast*/ 4) {
				updating_nodeData = true;
				switch_instance_changes.nodeData = /*flowObject*/ ctx[19];
				internal.add_flush_callback(() => updating_nodeData = false);
			}

			if (switch_value !== (switch_value = constructors[/*flowObject*/ ctx[19].type])) {
				if (switch_instance) {
					internal.group_outros();
					const old_component = switch_instance;

					internal.transition_out(old_component.$$.fragment, 1, 0, () => {
						internal.destroy_component(old_component, 1);
					});

					internal.check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					internal.binding_callbacks.push(() => internal.bind(switch_instance, 'nodeData', switch_instance_nodeData_binding));
					switch_instance.$on("delete", /*delete_handler*/ ctx[14]);
					switch_instance.$on("insertAfter", insertAfter_handler);
					switch_instance.$on("moveExpression", /*moveExpression_handler*/ ctx[16]);
					internal.create_component(switch_instance.$$.fragment);
					internal.transition_in(switch_instance.$$.fragment, 1);
					internal.mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		r: function measure() {
			rect = div.getBoundingClientRect();
		},
		f: function fix() {
			internal.fix_position(div);
			stop_animation();
			internal.add_transform(div, rect);
		},
		a: function animate$1() {
			stop_animation();
			stop_animation = internal.create_animation(div, rect, animate.flip, { duration: 400 });
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) internal.transition_in(switch_instance.$$.fragment, local);

			if (local) {
				internal.add_render_callback(() => {
					if (!div_transition) div_transition = internal.create_bidirectional_transition(div, squish, { duration: 300, opacity: 0.4, start: 0.2 }, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (switch_instance) internal.transition_out(switch_instance.$$.fragment, local);

			if (local) {
				if (!div_transition) div_transition = internal.create_bidirectional_transition(div, squish, { duration: 300, opacity: 0.4, start: 0.2 }, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div);
			if (switch_instance) internal.destroy_component(switch_instance);
			if (detaching && div_transition) div_transition.end();
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(84:8) {#each $ast.main.body as flowObject, i (flowObject.id)}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div3;
	let functioninfotab;
	let updating_info;
	let t0;
	let div2;
	let div0;
	let t1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let div1;
	let current;
	let mounted;
	let dispose;

	function functioninfotab_info_binding(value) {
		/*functioninfotab_info_binding*/ ctx[10](value);
	}

	let functioninfotab_props = {};

	if (/*$ast*/ ctx[2].main.info !== void 0) {
		functioninfotab_props.info = /*$ast*/ ctx[2].main.info;
	}

	functioninfotab = new FunctionInfoTab({
			props: functioninfotab_props,
			$$inline: true
		});

	internal.binding_callbacks.push(() => internal.bind(functioninfotab, 'info', functioninfotab_info_binding));
	let each_value = /*$ast*/ ctx[2].main.body;
	internal.validate_each_argument(each_value);
	const get_key = ctx => /*flowObject*/ ctx[19].id;
	internal.validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div3 = internal.element("div");
			internal.create_component(functioninfotab.$$.fragment);
			t0 = internal.space();
			div2 = internal.element("div");
			div0 = internal.element("div");
			t1 = internal.space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = internal.space();
			div1 = internal.element("div");
			internal.attr_dev(div0, "class", "bumper-zone svelte-1ezr4ng");
			internal.toggle_class(div0, "hoverDrag", /*hoverPrepend*/ ctx[0]);
			internal.add_location(div0, file$1, 76, 8, 2180);
			internal.attr_dev(div1, "class", "bumper-zone svelte-1ezr4ng");
			internal.toggle_class(div1, "hoverDrag", /*hoverAppend*/ ctx[1]);
			internal.add_location(div1, file$1, 96, 8, 3258);
			internal.attr_dev(div2, "class", "flow-wrapper svelte-1ezr4ng");
			internal.add_location(div2, file$1, 75, 4, 2145);
			internal.attr_dev(div3, "class", "app-window-wrapper svelte-1ezr4ng");
			internal.add_location(div3, file$1, 68, 0, 1896);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div3, anchor);
			internal.mount_component(functioninfotab, div3, null);
			internal.append_dev(div3, t0);
			internal.append_dev(div3, div2);
			internal.append_dev(div2, div0);
			internal.append_dev(div2, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			internal.append_dev(div2, t2);
			internal.append_dev(div2, div1);
			current = true;

			if (!mounted) {
				dispose = [
					internal.listen_dev(
						div0,
						"drop",
						internal.stop_propagation(internal.prevent_default(flowDropHandler({
							contextName: 'flow',
							stateChangeCallback: /*prependDrop*/ ctx[5]
						}))),
						false,
						true,
						true
					),
					internal.listen_dev(div0, "dragover", internal.prevent_default(dragOverHandler), false, true, false),
					internal.listen_dev(div0, "dragenter", /*dragenter_handler*/ ctx[11], false, false, false),
					internal.listen_dev(div0, "dragleave", /*dragleave_handler*/ ctx[12], false, false, false),
					internal.listen_dev(div1, "dragenter", /*dragenter_handler_1*/ ctx[17], false, false, false),
					internal.listen_dev(div1, "dragleave", /*dragleave_handler_1*/ ctx[18], false, false, false),
					internal.listen_dev(div3, "dragover", internal.prevent_default(dragOverHandler), false, true, false),
					internal.listen_dev(
						div3,
						"drop",
						internal.stop_propagation(internal.prevent_default(flowDropHandler({
							contextName: 'flow',
							stateChangeCallback: /*appendDrop*/ ctx[6]
						}))),
						false,
						true,
						true
					)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			const functioninfotab_changes = {};

			if (!updating_info && dirty & /*$ast*/ 4) {
				updating_info = true;
				functioninfotab_changes.info = /*$ast*/ ctx[2].main.info;
				internal.add_flush_callback(() => updating_info = false);
			}

			functioninfotab.$set(functioninfotab_changes);

			if (dirty & /*hoverPrepend*/ 1) {
				internal.toggle_class(div0, "hoverDrag", /*hoverPrepend*/ ctx[0]);
			}

			if (dirty & /*constructors, $ast, deleteFlowStep, insertAfterStep, handleMoveExpression*/ 900) {
				each_value = /*$ast*/ ctx[2].main.body;
				internal.validate_each_argument(each_value);
				internal.group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				internal.validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = internal.update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div2, internal.fix_and_outro_and_destroy_block, create_each_block, t2, get_each_context);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				internal.check_outros();
			}

			if (dirty & /*hoverAppend*/ 2) {
				internal.toggle_class(div1, "hoverDrag", /*hoverAppend*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			internal.transition_in(functioninfotab.$$.fragment, local);

			for (let i = 0; i < each_value.length; i += 1) {
				internal.transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			internal.transition_out(functioninfotab.$$.fragment, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				internal.transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div3);
			internal.destroy_component(functioninfotab);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			internal.run_all(dispose);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function dragOverHandler(event) {
	
} // do stuff like change the cursor

function instance$1($$self, $$props, $$invalidate) {
	let $ast;
	internal.validate_store(ast, 'ast');
	internal.component_subscribe($$self, ast, $$value => $$invalidate(2, $ast = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('FlowController', slots, []);
	let hoverPrepend = false;

	function setHoverPrepend(newValue) {
		$$invalidate(0, hoverPrepend = newValue);
	}

	let hoverAppend = false;

	function setHoverAppend(newValue) {
		$$invalidate(1, hoverAppend = newValue);
	}

	function prependDrop(node) {
		setHoverPrepend(false);

		if (node.currentIndex !== undefined) {
			$ast.main.body.splice(node.currentIndex, 1);
			node = node.moveData;
		}

		internal.set_store_value(ast, $ast.main.body = [node, ...$ast.main.body], $ast);
	}

	function appendDrop(node) {
		setHoverAppend(false);

		if (node.currentIndex !== undefined) {
			$ast.main.body.splice(node.currentIndex, 1);
			node = node.moveData;
		}

		internal.set_store_value(ast, $ast.main.body = [...$ast.main.body, node], $ast);
	}

	function handleMoveExpression({ moveData, currentIndex, newIndex }) {
		if (newIndex === currentIndex + 1) return;
		$ast.main.body.splice(currentIndex, 1);
		newIndex = currentIndex < newIndex ? newIndex - 1 : newIndex;
		$ast.main.body.splice(newIndex, 0, moveData);
		ast.set($ast);
	}

	function deleteFlowStep(index) {
		$ast.main.body.splice(index, 1);
		ast.set($ast);
	}

	function insertAfterStep(index, dataToInsert) {
		$ast.main.body.splice(index + 1, 0, dataToInsert);
		ast.set($ast);
	}

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FlowController> was created with unknown prop '${key}'`);
	});

	function functioninfotab_info_binding(value) {
		if ($$self.$$.not_equal($ast.main.info, value)) {
			$ast.main.info = value;
			ast.set($ast);
		}
	}

	const dragenter_handler = () => setHoverPrepend(true);
	const dragleave_handler = () => setHoverPrepend(false);

	function switch_instance_nodeData_binding(value, flowObject, each_value, i) {
		each_value[i] = value;
		ast.set($ast);
	}

	const delete_handler = event => deleteFlowStep(event.detail);
	const insertAfter_handler = (i, event) => insertAfterStep(i, event.detail);
	const moveExpression_handler = event => handleMoveExpression(event.detail);
	const dragenter_handler_1 = () => setHoverAppend(true);
	const dragleave_handler_1 = () => setHoverAppend(false);

	$$self.$capture_state = () => ({
		FunctionInfoTab,
		flowDropHandler,
		ast,
		constructors,
		squish,
		flip: animate.flip,
		hoverPrepend,
		setHoverPrepend,
		hoverAppend,
		setHoverAppend,
		dragOverHandler,
		prependDrop,
		appendDrop,
		handleMoveExpression,
		deleteFlowStep,
		insertAfterStep,
		$ast
	});

	$$self.$inject_state = $$props => {
		if ('hoverPrepend' in $$props) $$invalidate(0, hoverPrepend = $$props.hoverPrepend);
		if ('hoverAppend' in $$props) $$invalidate(1, hoverAppend = $$props.hoverAppend);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		hoverPrepend,
		hoverAppend,
		$ast,
		setHoverPrepend,
		setHoverAppend,
		prependDrop,
		appendDrop,
		handleMoveExpression,
		deleteFlowStep,
		insertAfterStep,
		functioninfotab_info_binding,
		dragenter_handler,
		dragleave_handler,
		switch_instance_nodeData_binding,
		delete_handler,
		insertAfter_handler,
		moveExpression_handler,
		dragenter_handler_1,
		dragleave_handler_1
	];
}

class FlowController extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance$1, create_fragment$1, internal.safe_not_equal, {});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FlowController",
			options,
			id: create_fragment$1.name
		});
	}
}

suite('FlowController', function() {
    test('Render mock data json', function() {
        const { getAllByText } = svelte$1.render(FlowController);

        chai.assert.strictEqual(getAllByText("Drag an action here").length, 4, "Flow controller isn't rendering empty expression statements");
    });
});

/* src/components/Header.svelte generated by Svelte v3.46.4 */

const file = "src/components/Header.svelte";

function create_fragment(ctx) {
	let div;
	let h1;

	const block = {
		c: function create() {
			div = internal.element("div");
			h1 = internal.element("h1");
			h1.textContent = `${headerText}`;
			internal.add_location(h1, file, 5, 4, 78);
			internal.attr_dev(div, "class", "header svelte-1w1jjle");
			internal.add_location(div, file, 4, 0, 53);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			internal.insert_dev(target, div, anchor);
			internal.append_dev(div, h1);
		},
		p: internal.noop,
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (detaching) internal.detach_dev(div);
		}
	};

	internal.dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const headerText = "Z-Flow";

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	internal.validate_slots('Header', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ headerText });
	return [];
}

class Header extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		internal.init(this, options, instance, create_fragment, internal.safe_not_equal, {});

		internal.dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Header",
			options,
			id: create_fragment.name
		});
	}
}

suite('testing', function() {
    test('it works?', function() {
        const { getByText } = svelte$1.render(Header);

        chai.assert.isNotNull(getByText("Z-Flow"));
    });
});
